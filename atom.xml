<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>布袋青年</title>
  
  <subtitle>布袋青年</subtitle>
  <link href="https://budai.pages.dev/atom.xml" rel="self"/>
  
  <link href="https://budai.pages.dev/"/>
  <updated>2026-01-17T09:06:26.225Z</updated>
  <id>https://budai.pages.dev/</id>
  
  <author>
    <name>烽火戏诸诸诸侯</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 工程构建部署</title>
    <link href="https://budai.pages.dev/build/python/"/>
    <id>https://budai.pages.dev/build/python/</id>
    <published>2026-01-16T16:00:00.000Z</published>
    <updated>2026-01-17T09:06:26.225Z</updated>
    
    <content type="html"><![CDATA[<p><code>Docker</code> 通过容器化技术为服务提供了环境隔离且便捷化的服务管理，今天就让我们一起来看看如何将 <code>Python</code> 工程打包为 <code>Docker Image</code> 并实现服务运行。</p><h4 id="1-镜像构建"><a href="#1-镜像构建" class="headerlink" title="1. 镜像构建"></a>1. 镜像构建</h4><p>以 <code>FastAPI</code> 项目为例，其中 <code>src</code> 为源码目录，<code>requirements.txt</code> 为依赖配置，如下图所示。<br><img src="/album/loading.gif" data-original="/album/article/python/build/1.png"></p><p>将上述工程源码完整拷贝至服务器目录，并在同级新建 <code>Dockerfile</code> 文件得到下图结构。<br><img src="/album/loading.gif" data-original="/album/article/python/build/2.png"></p><p>接下来便可编写 <code>Dockerfile</code> 进行镜像构建，文件内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash">FROM python:3.11-slimWORKDIR /app<span class="token comment" spellcheck="true"># 系统依赖</span>RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y \    gcc g++ libstdc++6 \    <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -rf /var/lib/apt/lists/*<span class="token comment" spellcheck="true"># 依赖安装</span>COPY requirements.txt <span class="token keyword">.</span>RUN pip <span class="token function">install</span> --no-cache-dir -r requirements.txt<span class="token comment" spellcheck="true"># 源码拷贝</span>COPY src ./src<span class="token comment" spellcheck="true"># 环境变量</span>ENV PYTHONPATH<span class="token operator">=</span>/app/src<span class="token comment" spellcheck="true"># 暴露端口</span>EXPOSE 8091<span class="token comment" spellcheck="true"># 启动命令</span>CMD <span class="token punctuation">[</span><span class="token string">"uvicorn"</span>, <span class="token string">"main:app"</span>, <span class="token string">"--host"</span>, <span class="token string">"0.0.0.0"</span>, <span class="token string">"--port"</span>, <span class="token string">"8091"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>COPY</code> 用于复制宿主机文件或目录至构建好的镜像中，其命令格式如下：</p><pre class="line-numbers language-bash"><code class="language-bash">COPY <span class="token operator">&lt;</span>容器中目录<span class="token operator">></span> <span class="token operator">&lt;</span>待拷贝目标<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需特别注意 <code>COPY</code> 命令并不支持读取服务器绝对路径，而是根据 <code>Dockerfile</code> 文件目录作为起始路径进行读取，因此需要将待拷贝内容置于 <code>Dockerfile</code> 同级下。</p><p>如下述配置通过绝对路径 <code>/home/data/python/src</code> 复制目录在编译时将失败。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 非法，不支持绝对路径</span>COPY src /home/data/python/src<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-离线编译"><a href="#2-离线编译" class="headerlink" title="2. 离线编译"></a>2. 离线编译</h4><p>通过上述虽可实现镜像构建，但注意到每次构建镜像都会触发 <code>requirements.txt</code> 依赖的在线下载。而对应绝多数服务更新中往往仅涉及代码变更，每次都触发依赖下载都将增加服务构建耗时，显然并不合理。</p><p>因此，在更多的场景下我们往往会采取离线编译的方式，即使用已经存在依赖文件 <code>.whl</code> 进行构建。</p><p>但使用离线构建需注意一点，工程中使用的部分依赖可能并不直接提供 <code>.whl</code> 文件而需要我们自行构建。</p><p>此时则需要使用 <code>wheel</code> 工具手动编译依赖，通过下述命令下载编译工具。</p><pre class="line-numbers language-bash"><code class="language-bash">pip <span class="token function">install</span> build wheel setuptools<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完成后以 <code>langdetect</code> 工具库为例，通过 <code>pip download</code> 下载指定版本依赖得到 <code>.tar.gz</code> 文件，解压后进入目录通过对应命令编辑，完成后便会在 <code>dist/</code>  目录下生成 <code>.whl</code> 依赖文件。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载依赖</span>pip download langdetect<span class="token operator">==</span>1.0.9<span class="token comment" spellcheck="true"># 依赖解包</span><span class="token function">tar</span> xf langdetect-1.0.9.tar.gz<span class="token comment" spellcheck="true"># 依赖编译</span><span class="token function">cd</span> langdetect-1.0.9python -m build --wheel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而对应提供了 <code>.whl</code> 的依赖而言，则可直接根据<code> requirements.txt</code> 下载。</p><p>如下则通过 <code>requirements.txt</code> 下载依赖并统一输出至 <code>wheelhouse</code> 目录。</p><pre class="line-numbers language-bash"><code class="language-bash">pip download -r requirements.txt -d wheelhouse<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述步骤完成后回到 <code>Dockerfile</code> 中，替换之前的 <code>pip install</code> 命令，通过 <code>--find-links=/wheelhouse</code> 关联本地依赖文件，在构建时则不再触发在线依赖下载。</p><p>通过此方式，避免了每次重复依赖的网络下载开销，极大提供了服务构建效率。</p><pre class="line-numbers language-bash"><code class="language-bash">FROM python:3.11-slimWORKDIR /appRUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y \    gcc g++ libstdc++6 \    <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -rf /var/lib/apt/lists/*<span class="token comment" spellcheck="true"># 依赖安装</span>COPY wheelhouse /wheelhouseCOPY requirements.txt <span class="token keyword">.</span>RUN pip <span class="token function">install</span> --no-index --find-links<span class="token operator">=</span>/wheelhouse -r requirements.txtCOPY src ./srcENV PYTHONPATH<span class="token operator">=</span>/app/srcEXPOSE 8091CMD <span class="token punctuation">[</span><span class="token string">"uvicorn"</span>, <span class="token string">"main:app"</span>, <span class="token string">"--host"</span>, <span class="token string">"0.0.0.0"</span>, <span class="token string">"--port"</span>, <span class="token string">"8091"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-服务运行"><a href="#3-服务运行" class="headerlink" title="3. 服务运行"></a>3. 服务运行</h4><p>准备好 <code>Dockerfile</code> 后通过 <code>build</code> 构建镜像，完成后可通过 <code>docker images</code> 查询已有镜像信息。</p><pre class="line-numbers language-bash"><code class="language-bash">docker build -t test-fastapi:1.0 <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>镜像文件构建完毕之后便可同 <code>docker run</code> 启动服务，这里便不再过多赘述。</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \-name test-fastapi \-p 8091:8091 \test-fastapi:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 通过容器化技术为服务提供了环境隔离且便捷化的服务管理，今天就让我们一起来看看如何将 &lt;code&gt;Python&lt;/code&gt; 工程打包为 &lt;code&gt;Docker Image&lt;/code&gt; 并实现服务运行。&lt;/p&gt;
&lt;h4 id=&quot;1-</summary>
      
    
    
    
    <category term="编译构建" scheme="https://budai.pages.dev/categories/%E7%BC%96%E8%AF%91%E6%9E%84%E5%BB%BA/"/>
    
    
    <category term="Docker" scheme="https://budai.pages.dev/tags/Docker/"/>
    
    <category term="Python" scheme="https://budai.pages.dev/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 基础教程</title>
    <link href="https://budai.pages.dev/linux/docker/kubernetes/"/>
    <id>https://budai.pages.dev/linux/docker/kubernetes/</id>
    <published>2026-01-11T16:00:00.000Z</published>
    <updated>2026-01-21T13:23:38.668Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中我们分享了 <code>Docker</code> 与 <code>Docker Compose</code> 的使用，前者通过容器化技术简化了服务管理，而后者则提供 <code>YAML</code> 方式进一步简化 <code>Docker</code> 维护成本。</p><p>而今天则让我们聚焦于 <code>K8S(Kubernetes)</code>，其提供了容器化编排能力，在规模化服务运维上提供了强力保障。</p><p>随着 <code>Kubernetes</code> 的生态的发展，其已然成为当下服务运维的主流选择，那么今天让我们一同学习如何基于 <code>K8S</code> 实现服务的部署与管理。</p><h3 id="一、集群搭建"><a href="#一、集群搭建" class="headerlink" title="一、集群搭建"></a>一、集群搭建</h3><h4 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h4><p>开始前需先行配置相关的环境，通过下面命令关闭 <code>swap</code>，完成后可通过 <code>free -m</code> 验证。</p><pre class="line-numbers language-bash"><code class="language-bash">swapoff -a<span class="token function">sed</span> -i <span class="token string">'/swap/d'</span> /etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同时，若在测试环境则建议先行关闭服务器防火墙避免后续访问异常。</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl stop firewalldsystemctl disable firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-Minikube"><a href="#2-Minikube" class="headerlink" title="2. Minikube"></a>2. Minikube</h4><p>在后续的教程中都是基于 <code>Docker</code> 实现，因此部署 <code>Kubernetes</code> 前需确保 <code>Docker</code> 已安装并运行，可参考：<a href="https://budai.pages.dev/linux/docker/basic/">Docker基础入门</a>。</p><p>完成后便可着手部署本地 <code>Kubernetes</code> 服务，这里选择 <code>Minikube</code> 搭建服务集群。</p><p>以 <code>CentOS7</code> 服务器为例，访问 <code>GitHub</code> 下载 <code>minikube-linux-amd64</code> 二进制文件并上传至服务器，或使用 <code>curl</code> 命令在服务器上通过网络下载：</p><pre class="line-numbers language-bash"><code class="language-bash">curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载完成后则可进行安装，完成后输入 <code>minikube</code> 若显示 <code>help</code> 命令说明安装成功。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">install</span> minikube-linux-amd64 /usr/local/bin/minikube<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>服务安装后便可启动 <code>Kubernetes</code> 服务，其中 <code>--driver=docker</code> 表示基于 <code>Docker</code> 服务。</p><p>同时 <code>minikube</code> 默认不支持 <code>root</code> 账户运行，因此需 <code>--force</code> 强制启动进而跳过校验。</p><pre class="line-numbers language-bash"><code class="language-bash">minikube start --driver<span class="token operator">=</span>docker --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若需以普通用户身份启动，可通过下述命令新建用户后启动。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建用户并加入组</span><span class="token function">useradd</span> budai<span class="token function">usermod</span> -aG docker budai<span class="token comment" spellcheck="true"># 切换用户并启动</span><span class="token function">su</span> budaiminikube start --driver<span class="token operator">=</span>docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成上述步骤后通过 <code>minikube status</code> 查看服务状态，返回下述结果则说明成功。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># minikube status</span>minikubetype: Control Planehost: Runningkubelet: Runningapiserver: Runningkubeconfig: Configured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-命令关联"><a href="#3-命令关联" class="headerlink" title="3. 命令关联"></a>3. 命令关联</h4><p>为了更方便后续的使用，这边需要为 <code>kubectl</code> 命令创建短链别名。</p><p>通过 <code>vim .bashrc</code> 编辑环境变量，在配置中加入 <code>alias kubectl=&quot;minikube kubectl --&quot;</code> 后保存退出。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">alias</span> rm<span class="token operator">=</span><span class="token string">'rm -i'</span><span class="token function">alias</span> cp<span class="token operator">=</span><span class="token string">'cp -i'</span><span class="token function">alias</span> mv<span class="token operator">=</span><span class="token string">'mv -i'</span><span class="token function">alias</span> kubectl<span class="token operator">=</span><span class="token string">"minikube kubectl --"</span><span class="token comment" spellcheck="true"># Source global definitions</span><span class="token keyword">if</span> <span class="token punctuation">[</span> -f /etc/bashrc <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token keyword">.</span> /etc/bashrc<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存退出后通过 <code>source</code> 命令刷新配置，便可直接使用 <code>kubectl</code> 命令。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> .bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="二、POD管理"><a href="#二、POD管理" class="headerlink" title="二、POD管理"></a>二、POD管理</h3><h4 id="1-基础介绍"><a href="#1-基础介绍" class="headerlink" title="1. 基础介绍"></a>1. 基础介绍</h4><p>在 <code>Docker</code> 服务中我们最熟悉的莫过于 <code>container</code> 容器了，而在 <code>Kubernetes</code> 中 <code>Pod</code> 为最小的可调度、可运行单元，是一个或多个容器的组合。<br><img src="/album/loading.gif" data-original="/album/article/linux/k8s/1.png"></p><p>当启动 <code>Pod</code> 时会为其分配单独 <code>IP</code>，不同 <code>Pod</code> 之间可通过此分配的 <code>IP</code> 进行通讯访问。</p><p>较为经典的场景即日志监控，将日志服务与业务系统部署于同一 <code>Pod</code> 中，当系统输出日志信息后由日志服务推送数据至其它 <code>Pod</code> 用于进一步加工处理。</p><h4 id="2-配置格式"><a href="#2-配置格式" class="headerlink" title="2. 配置格式"></a>2. 配置格式</h4><p>在 <code>Kubernetes</code> 中服务的管理与 <code>Docker Compose</code> 类似通过 <code>YAML</code> 文件进行管理。</p><p>下面让我们来看一个具体的 <code>Pod</code> 实例其 <code>test-pod.yaml</code> 文件配置，内容如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pod  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Always  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test      <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test<span class="token punctuation">:</span><span class="token number">1.0</span>      <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上述 <code>yaml</code> 各项参数作用参考下表，详细说明可访问官网查看：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a>。</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">属性</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">kind</td>        <td style="text-align: center;">配置类型。</td>    </tr>    <tr>        <td style="text-align: center;">metadata.name</td>        <td style="text-align: center;">用于指定 Pod 名称。</td>    </tr>    <tr>        <td style="text-align: center;">metadata.labels</td>        <td style="text-align: center;">用于指定 Pod 标签。</td>    </tr>    <tr>        <td style="text-align: center;">spec.restartPolicy</td>        <td style="text-align: center;">Pod 重启策略。</td>    </tr>    <tr>        <td style="text-align: center;">spec.containers</td>        <td style="text-align: center;">用于配置 Pod 中运行的容器信息。</td>    </tr></table></br><p>其中标签 <code>(labels)</code> 最核心的作用便是用于资源选择，让其它服务能够选中 <code>Pod</code>，后续会以具体示例演示。</p><p>同时，<code>containers</code> 容器中配置的镜像拉取默认规则为读取 <code>Docker Hub</code>，通过 <code>imagePullPolicy</code> 便可指定拉取策略，可选值如下：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">属性</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">Always</td>        <td style="text-align: center;">默认值，总是拉取镜像。</td>    </tr>    <tr>        <td style="text-align: center;">IfNotPresent</td>        <td style="text-align: center;">当本地不存在时拉取镜像。</td>    </tr>    <tr>        <td style="text-align: center;">Never</td>        <td style="text-align: center;">只使用本地镜像，从不拉取。</td>    </tr></table><br/><p>除此之外，<code>Pod</code> 其余常见命令参考下表：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">命令</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">kubectl get pod</td>        <td style="text-align: center;">列举当前所有 Pod。</td>    </tr>    <tr>        <td style="text-align: center;">kubectl get pod -o wide</td>        <td style="text-align: center;">列举当前所有 Pod 详细信息。</td>    </tr>    <tr>        <td style="text-align: center;">kubectl get pod --show-labels</td>        <td style="text-align: center;">列举当前所有 Pod 及其 label。</td>    </tr>    <tr>        <td style="text-align: center;">kubectl delete pod pod-name</td>        <td style="text-align: center;">删除指定 Pod。</td>    </tr>    <tr>        <td style="text-align: center;">kubectl logs --follow pod-name</td>        <td style="text-align: center;">查看指定 Pod 日志。</td>    </tr></table><br/><p>同时与 <code>Docker</code> 中的 <code>exec</code> 类似，<code>Pod</code> 也支持类似语法访问 <code>Pod</code>，其语法如下：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl <span class="token function">exec</span> -it <span class="token operator">&lt;</span>pod-name<span class="token operator">></span> -- <span class="token operator">&lt;</span>command<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如进入 <code>test-pod</code> 节点内部其相对应的命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl <span class="token function">exec</span> -it test-pod -- /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-服务示例"><a href="#3-服务示例" class="headerlink" title="3. 服务示例"></a>3. 服务示例</h4><p>接下来以具体的 <code>Pod</code> 演示，准备 <code>Spring Boot</code> 项目定义接口返回当前节点的 <code>Host name</code>，代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api"</span><span class="token punctuation">)</span><span class="token keyword">public</span> TestResource <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        InetAddress inet <span class="token operator">=</span> InetAddress<span class="token punctuation">.</span><span class="token function">getLocalHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> inet<span class="token punctuation">.</span><span class="token function">getHostName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" say Hello!"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成后将工程打包为 <code>Docker Image</code>，可参考：<a href="/https://budai.pages.dev/build/maven/deploy/#toc-heading-9">Maven打包部署教程</a>，制作好镜像后通过 <code>load</code> 命令加载至 <code>Minikube</code> 中。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 构建镜像</span>docker build -t k8s-test:1.0 <span class="token keyword">.</span><span class="token comment" spellcheck="true"># 加载镜像</span>minikube image load k8s-test:1.0<span class="token comment" spellcheck="true"># 列举镜像</span>minikube image list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看 <code>minikube</code> 镜像时除了上述命令也可通过 <code>minikube ssh</code> 进入实例后使用普通 <code>docker</code> 命令查看。</p><p>镜像加载完毕后便可通过 <code>kubectl apply -f</code> 命令启动上述 <code>yaml</code> 定义的 <code>Pod</code> 服务。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动 Pod 实例</span>kubectl apply -f test-pod.yaml  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时便可通过 <code>kubectl get pod</code> 查看已有的 <code>Pod</code>，如下 <code>Running</code> 则表示以启动运行。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod</span>NAME       READY   STATUS    RESTARTS   AGEtest-pod   1/1     Running   0          1s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 <code>-o wide</code> 参数可查看 <code>Pod</code> 详细信息，通过 <code>IP</code> 测试之前服务声明的接口可以看到能够正常响应。</p><p>至此，我们便完成了最基础的 <code>Kubernetes</code> 服务的启动运行。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -o wide</span>NAME       READY   STATUS    RESTARTS   AGE     IP           NODE       NOMINATED NODE   READINESS GATEStest-pod   1/1     Running   0          1s      10.244.0.4   minikube   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl exec -it test-pod -- curl http://10.244.0.4:9090/api/hello</span>test-pod say Hello<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-重启策略"><a href="#4-重启策略" class="headerlink" title="4. 重启策略"></a>4. 重启策略</h4><p>不同于手动方式的服务部署，<code>Kubernetes</code> 支持监控服务状态并实现异常自启。</p><p>当 <code>Pod</code> 中的容器退出时，<code>Kubernetes</code> 会以指数级回退延迟机制（10 秒、20 秒、40 秒…）重启容器， 上限为 <code>300</code> 秒。当容器顺利执行了 <code>10</code> 分钟，<code>Kubernetes</code> 就会重置该容器的重启延迟计时器。</p><p>对应 <code>Pod</code> 实例的重启策略配置通过 <code>restartPolicy</code> 配置，可选参数如下：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">属性</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">Always</td>        <td style="text-align: center;">默认值，只要容器终止就自动重启。</td>    </tr>    <tr>        <td style="text-align: center;">OnFailure</td>        <td style="text-align: center;">只有在容器错误退出（退出状态非零）时才重新启动容器。</td>    </tr>    <tr>        <td style="text-align: center;">Never</td>        <td style="text-align: center;">不会自动重启已终止的容器。</td>    </tr></table><br/><p>需注意这里重启策略是针对实例中容器而言，即当 <code>Pod</code> 内进程异常时重启 <code>Pod</code> 服务，而手动的删除 <code>Pod</code> 并不会触发自动重新拉取并启动 <code>Pod</code>。</p><p>下面以示例进行介绍，首先通过 <code>-watch</code> 来监听 <code>Pod</code> 的变化情况。</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get pods -watch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建命令窗口通过 <code>exec</code> 查看服务进程，并使用 <code>kill &lt;pid&gt;</code> 命令关闭进程。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看进程</span><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl exec -it test-pod -- ps aux</span>USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot           1 15.6  2.9 3167616 122228 ?      Ssl  12:23   0:03 java -jar /k8s-test.jarroot          30  0.0  0.0  10864  2476 pts/0    Rs+  12:24   0:00 <span class="token function">ps</span> aux<span class="token comment" spellcheck="true"># 关闭进程</span><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl exec -it test-pod -- kill 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回到刚才的 <code>watch</code> 窗口，可以看到在首次启动后状态为 <code>Running</code>，而当手动 <code>kill</code> 转为 <code>Error</code> 后便自动触发重启，服务再次变为 <code>Running</code> 可用。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pods -w</span>NAME       READY   STATUS    RESTARTS   AGEtest-pod   0/1     Pending   0          0stest-pod   0/1     Pending   0          0stest-pod   0/1     ContainerCreating   0          0stest-pod   1/1     Running             0          1stest-pod   0/1     Error               0          41stest-pod   1/1     Running             1 <span class="token punctuation">(</span>1s ago<span class="token punctuation">)</span>   42s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-目录挂载"><a href="#5-目录挂载" class="headerlink" title="5. 目录挂载"></a>5. 目录挂载</h4><p>熟悉 <code>Docker</code> 的都知道，容器的每次删除重建并不会保留其中的数据文件，故通常会采用目录挂载的方式实现数据的持久化。</p><p>在 <code>Pod</code> 中也并不例外，每次执行 <code>delete pod</code> 后其容器中的所有内载文件将一并删除无法找回。</p><p>因此，部署服务时对于重要数据同样需配置目录映射，在 <code>Docker</code> 中若需实现容器与宿主机的目录映射通过 <code>-v</code> 参数便可实现，而在 <code>Pod</code> 中配置方式与其相似。</p><p>还是以刚刚的 <code>test-pod.yaml</code> 文件为例，若需要将宿主机的 <code>/home/data</code> 目录与容器目录 <code>/app/data</code> 相映射，其配置如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pod  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Always  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test      <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test<span class="token punctuation">:</span><span class="token number">1.0</span>      <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent      <span class="token comment" spellcheck="true"># 容器目录</span>      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> host<span class="token punctuation">-</span>data          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /app/data    <span class="token comment" spellcheck="true"># 宿主机目录</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> host<span class="token punctuation">-</span>data          <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>            <span class="token key atrule">path</span><span class="token punctuation">:</span> /home/data            <span class="token key atrule">type</span><span class="token punctuation">:</span> DirectoryOrCreate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>volumes</code> 用于定义宿主机目录信息，而 <code>volumeMounts</code> 相对应为容器目录信息，二者通过 <code>volumes.name</code> 与 <code>volumeMounts.name</code> 实现关联。</p><p>同时，由于我们是基于 <code>Minikube</code> 所以这边需要增加一步操作将宿主机与 <code>Minikube</code> 进行映射：</p><pre class="line-numbers language-bash"><code class="language-bash">minikube <span class="token function">mount</span> <span class="token operator">&lt;</span>宿主机目录<span class="token operator">></span>:<span class="token operator">&lt;</span>Minikube 目录<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过上述的配置即可实现 <code>Pod</code> 的目录映射，但你也发现的问题所在即强依赖于服务节点，在集群模式下的 <code>Kubernetes</code> 不同节点可能分步在不同服务器上，映射目录并不互通。</p><p>因此对于集群目录映射提供了 <code>PersistentVolumeClaim</code> 持久化配置方式，将数据独立存储管理，如下配置中声明了空间大小为 <code>5GB</code> 的持久化目录。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>pvc<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 5Gi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而后同样通过 <code>volumes</code> 与 <code>volumeMounts</code> 即可实现目录映射，此时即便删除 <code>test-pod</code> 节点，数据仍会持久化保存于 <code>my-pvc</code> 当中。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>pod  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Always  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test      <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test<span class="token punctuation">:</span><span class="token number">1.0</span>      <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent      <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pers<span class="token punctuation">-</span>data          <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /app/data    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> pers<span class="token punctuation">-</span>data          <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>            <span class="token key atrule">claimName</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>pvc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、Deployment"><a href="#三、Deployment" class="headerlink" title="三、Deployment"></a>三、Deployment</h3><h4 id="1-基础介绍-1"><a href="#1-基础介绍-1" class="headerlink" title="1. 基础介绍"></a>1. 基础介绍</h4><p>在上述的介绍中，我们成功启动了单个 <code>Pod</code> 实例，但在真正的应用场景，常伴随着大批量的集群化服务。</p><p>上述的方式虽然达到效果，但显然效率过于低下，因此 <code>Kubernetes</code> 中提供了 <code>Deployment</code> 提供高度集成的集群化 <code>Pod</code> 服务管理。<br><img src="/album/loading.gif" data-original="/album/article/linux/k8s/2.png"></p><p>同样的，以具体的 <code>test-deployment.yaml</code> 配置示例进行介绍说明，文件内容如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test          <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test<span class="token punctuation">:</span><span class="token number">1.0</span>          <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置中 <code>kind</code> 指定为 <code>Deployment</code>，配置说明参考下表，详细说明可访问官网：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a>。</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">方法</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">replicas</td>        <td style="text-align: center;">集群副本实例数量。</td>    </tr>    <tr>        <td style="text-align: center;">selector.matchLabels.app</td>        <td style="text-align: center;">指定被当前 Deployment 管理的 Pod。</td>    </tr>    <tr>        <td style="text-align: center;">template.metadata.labels.app</td>        <td style="text-align: center;">当前 Deployment 创建 Pod 时设置的标签。</td>    </tr></table></br><p>其中容器信息 <code>containers</code> 配置项与先前并无差异，这里着重说明 <code>label</code> 的配置项。</p><p>正如最开始提到的，<code>label</code> 用于 <code>selector</code> 的资源选择，当 <code>K8S</code> 中运行多个 <code>Pod</code> 实例时，<code>selector.matchLabels.app</code> 用于标识哪些 <code>Pod</code> 受当前 <code>Deployment</code> 的管理。而 <code>template.metadata.labels.app</code> 则作用于 <code>Deployment</code> 创建 <code>Pod</code> 时为这些 <code>Pod</code> 指定标签。</p><p>通常情况下，同一份 <code>Deployment</code> 配置文件下 <code>selector.matchLabels.app</code> 与 <code>template.metadata.labels.app</code> 值需保持一致。</p><h4 id="2-副本集群"><a href="#2-副本集群" class="headerlink" title="2. 副本集群"></a>2. 副本集群</h4><p>在高可用的模式下，部署常采用分布式的形式存在，通过多实例保证在部分宕机的下服务仍保持可用。</p><p>在传统的服务部署模式下，需要手动启动多个实例服务，通过 <code>Nginx</code> 等代理工具实现负载均衡。<br><img src="/album/loading.gif" data-original="/album/article/linux/k8s/3.png"></p><p>而 <code>Deployment</code> 则可通过 <code>replicas</code> 简化多个实例启动这一步骤，由 <code>Kubernetes</code> 自动拉起多个节点。</p><p>还是以示例进行演示，让我们先删除之前创建的 <code>Pod</code> 实例。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod</span>NAME       READY   STATUS    RESTARTS   AGEtest-pod   1/1     Running   0          6d22h<span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl delete pod test-pod</span>pod <span class="token string">"test-pod"</span> deleted from default namespace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成后修改上述的配置文件的中 <code>replicas = 3</code> 后与之前一样通过 <code>apply -f</code> 启动 <code>Deployment</code>。</p><p>启动后可通过 <code>get deployment</code> 查看对应实例信息，同时 <code>get pod</code> 也可以看到 <code>3</code> 个 <code>Pod</code> 实例也已启动。</p><p>通过 <code>Deployment</code> 的 <code>replicas</code> 在集群化服务下我们不再需要手动逐一创建实例，通过配置便可一键启动。同时，<code>kubelet</code> 将监控 <code>Pod</code> 运行情况，当 <code>Pod</code> 不足 <code>replicas</code> 数量时会自动启动新的 <code>Pod</code> 实例。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动 Deployment</span><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl apply -f test-deployment.yaml </span>deployment.apps/test-deployment created<span class="token comment" spellcheck="true"># 查看 Deployment</span><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get deployment</span>NAME              READY   UP-TO-DATE   AVAILABLE   AGEtest-deployment   3/3     3            3           3s<span class="token comment" spellcheck="true"># 查看 Pod</span><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -o wide</span>NAME                               READY   STATUS    RESTARTS   AGE   IP            NODE       NOMINATED NODE   READINESS GATEStest-deployment-6ccd7f9d44-8nkzg   1/1     Running   0          7s    10.244.0.10   minikube   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>test-deployment-6ccd7f9d44-nnkch   1/1     Running   0          7s    10.244.0.12   minikube   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>test-deployment-6ccd7f9d44-pb2gb   1/1     Running   0          7s    10.244.0.11   minikube   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如手动删除 <code>8nkzg</code> 后缀的 <code>Pod</code> 实例后可以看到 <code>Deployment</code> 又自动启动了 <code>pgxdg</code> 后缀的实例。</p><p>如此一来，即便出现某个 <code>Pod</code> 宕机下线，<code>Kubernetes</code> 也能够立即发现且自动拉起服务，配合刚刚提到的重启策略 <code>(restartPolicy)</code>，二者搭配便可实现服务集群的高可用。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod</span>NAME                               READY   STATUS    RESTARTS   AGEtest-deployment-6ccd7f9d44-8nkzg   1/1     Running   0          6m27stest-deployment-6ccd7f9d44-nnkch   1/1     Running   0          6m27stest-deployment-6ccd7f9d44-pb2gb   1/1     Running   0          6m27s<span class="token comment" spellcheck="true"># 手动删除 Pod</span><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl delete pod test-deployment-6ccd7f9d44-8nkzg</span>pod <span class="token string">"test-deployment-6ccd7f9d44-8nkzg"</span> deleted from default namespace<span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod</span>NAME                               READY   STATUS    RESTARTS   AGEtest-deployment-6ccd7f9d44-nnkch   1/1     Running   0          6m41stest-deployment-6ccd7f9d44-pb2gb   1/1     Running   0          6m41stest-deployment-6ccd7f9d44-pgxdg   1/1     Running   0          3s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-滚动升级"><a href="#3-滚动升级" class="headerlink" title="3. 滚动升级"></a>3. 滚动升级</h4><p>基于 <code>replicas</code> 的多副本模式下，<code>Kubernetes</code> 提供滚动升级的能力。即多个实例节点并不会采取一次性下线重启，避免造成短期内的服务不可用，而是分阶段的服务替换升级。</p><p>还是以刚才的 <code>test-deployment.yaml</code> 为例，加入 <code>spec.strategy</code> 控制服务升级策略。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>     <span class="token key atrule">rollingUpdate</span><span class="token punctuation">:</span>      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> <span class="token number">1</span>      <span class="token key atrule">maxUnavailable</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test          <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test<span class="token punctuation">:</span><span class="token number">1.0</span>          <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>Deployment</code> 中针对 <code>strategy</code> 分别提供了下述两类配置策略：</p><blockquote><ul><li><code>Recreate</code>：在启动新的 <code>Pod</code> 节点前删除所有旧 <code>Pod</code> 实例，期间服务将不可用。</li><li><code>RollingUpdate</code>：分步删除与新增 <code>Pod</code> 节点，保证整个过程仍有可用服务。</li></ul></blockquote><p>启动 <code>Recreate</code> 相对较好理解，也是服务升级中最常用的方式，这里着重介绍滚动升级 <code>(RollingUpdate)</code>。</p><p>从上面的 <code>yaml</code> 配置中可以看到其提供了两个参数，更详细的介绍可参考官网：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#strategy">deployment-strategy</a>。</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">方法</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">maxSurge</td>        <td style="text-align: center;">最大峰值，指定可以的超出 replicas 的 Pod 数。</td>    </tr>    <tr>        <td style="text-align: center;">maxUnavailable</td>        <td style="text-align: center;">最大不可用，指定更新过程中不可用的 Pod 的上限。</td>    </tr></table></br><p>以上述的配置为例，<code>replicas = 3</code> 且 <code>maxSurge = 1</code>，即表示整个升级过程最多允许创建 <code>4 (replicas + maxSurge)</code> 个 <code>Pod</code>，同时仅允许 <code>1 (maxUnavailable)</code> 个 <code>Pod</code> 节点不可用。</p><p>整个服务升级过程如下，其中白色表示旧版本，灰色表示服务启动中不可用，黄色标识表示启动完成。<br><img src="/album/loading.gif" data-original="/album/article/linux/k8s/4.png"></p><p>同时，在 <code>Deployment</code> 中当每次修改 <code>spec.template</code> 中的配置都将触发 <code>Pod</code> 更新。因此，在针对服务的部署更新中，我们只需重新打包镜像后修改 <code>yaml</code> 中 <code>containers.image</code> 为新版后执行 <code>apply -f</code> 便可。</p><p>如此一来，在版本迭代发布时便无需手动繁杂的针对多个 <code>Pod</code> 手动进行更新发布，极大降低的工作量。</p><h4 id="4-服务回滚"><a href="#4-服务回滚" class="headerlink" title="4. 服务回滚"></a>4. 服务回滚</h4><p>使用 <code>Deployment</code> 的另一好处在于对每一次发布更新都会生成相应记录，默认下记录最近 <code>10</code> 次发布历史，<code>Kubernetes</code> 也基于此提供服务回滚的能力。</p><p>仍以刚才的工程为例，将其打包为 <code>k8s-test:2.0</code> 版本镜像，并修改 <code>test-deployment.yaml</code> 为内容为 <code>image: k8s-test:2.0</code> 后执行 <code>apply -f</code> 启动。</p><p>通过 <code>-w</code> 查看 <code>Pod</code> 的变化也恰好与刚才预期的滚动更新策略匹配，其按照之前预期的分节点停服重启。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pods -w</span>NAME                               READY   STATUS    RESTARTS   AGEtest-deployment-6ccd7f9d44-m5php   1/1     Running   0          13stest-deployment-6ccd7f9d44-qpx2v   1/1     Running   0          13stest-deployment-6ccd7f9d44-sn88q   1/1     Running   0          13stest-deployment-7bc4f88555-k256h   0/1     Pending   0          0stest-deployment-7bc4f88555-k256h   0/1     Pending   0          0stest-deployment-6ccd7f9d44-sn88q   1/1     Terminating   0          4m33stest-deployment-6ccd7f9d44-sn88q   1/1     Terminating   0          4m33stest-deployment-7bc4f88555-dpp96   0/1     Pending       0          0stest-deployment-7bc4f88555-k256h   0/1     ContainerCreating   0          0stest-deployment-7bc4f88555-dpp96   0/1     Pending             0          0stest-deployment-7bc4f88555-dpp96   0/1     ContainerCreating   0          0stest-deployment-6ccd7f9d44-sn88q   0/1     Error               0          4m33stest-deployment-7bc4f88555-k256h   1/1     Running             0          1stest-deployment-7bc4f88555-dpp96   1/1     Running             0          1stest-deployment-6ccd7f9d44-qpx2v   1/1     Terminating         0          4m34stest-deployment-6ccd7f9d44-sn88q   0/1     Error               0          4m34stest-deployment-6ccd7f9d44-sn88q   0/1     Error               0          4m34stest-deployment-7bc4f88555-cq6q2   0/1     Pending             0          0stest-deployment-7bc4f88555-cq6q2   0/1     Pending             0          0stest-deployment-6ccd7f9d44-qpx2v   1/1     Terminating         0          4m34stest-deployment-7bc4f88555-cq6q2   0/1     ContainerCreating   0          0stest-deployment-6ccd7f9d44-m5php   1/1     Terminating         0          4m34stest-deployment-6ccd7f9d44-m5php   1/1     Terminating         0          4m34stest-deployment-6ccd7f9d44-qpx2v   0/1     Error               0          4m34stest-deployment-6ccd7f9d44-m5php   0/1     Error               0          4m35stest-deployment-7bc4f88555-cq6q2   1/1     Running             0          1stest-deployment-6ccd7f9d44-m5php   0/1     Error               0          4m35stest-deployment-6ccd7f9d44-m5php   0/1     Error               0          4m35stest-deployment-6ccd7f9d44-qpx2v   0/1     Error               0          4m35stest-deployment-6ccd7f9d44-qpx2v   0/1     Error               0          4m35s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成更新升级之后，利用 <code>rollout status</code> 便可看到本次发布服务升级已经成功。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl rollout status deployment test-deployment</span>deployment <span class="token string">"test-deployment"</span> successfully rolled out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若需查看对应 <code>Deployment</code> 所有发布记录则可通过 <code>rollout history</code> 参数查看。</p><p>在下述中可以看到 <code>test-deployment</code> 一共经历了两次发布，首次创建以及刚刚的滚动升级。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl rollout history deployment test-deployment</span>deployment.apps/test-deployment REVISION  CHANGE-CAUSE1         <span class="token operator">&lt;</span>none<span class="token operator">></span>2         <span class="token operator">&lt;</span>none<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设此时发现服务出现异常需回滚至上一版本，则可通过 <code>rollout undo</code> 回滚至指定版本。</p><p>例如下示例指定 <code>--to-revision=1</code> 回滚至最原始版本，查看 <code>history</code> 也可看到生成了对应的升级记录。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 回滚服务</span><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl rollout undo deployment test-deployment --to-revision=1</span>deployment.apps/test-deployment rolled back<span class="token comment" spellcheck="true"># 查看历史</span><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl rollout history deployment test-deployment</span>deployment.apps/test-deployment REVISION  CHANGE-CAUSE2         <span class="token operator">&lt;</span>none<span class="token operator">></span>3         <span class="token operator">&lt;</span>none<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四、容器探针"><a href="#四、容器探针" class="headerlink" title="四、容器探针"></a>四、容器探针</h3><p>在上述的 <code>Deployment</code> 我们实现了服务的部署更新，而 <code>K8S</code> 其强大之处在于通过容器探针提供了服务启停与运行时的监控能力。</p><p>所谓容器探针，即在更新及运行过程中实时监控容器运行状态，根据探针结果执行一系列策略如自动重启等，下面就让我们一起了解其提供了哪些探针服务及其相应的作用。</p><h4 id="1-就绪探针"><a href="#1-就绪探针" class="headerlink" title="1. 就绪探针"></a>1. 就绪探针</h4><p><code>Kubernetes</code> 所提供的探针服务，接下来让我们先来看就绪探针 <code>(readinessProbe)</code> 其对应的作用。</p><p>故名思意其用于检测更新发布过程中服务是否已经可用，在多副本 <code>(replicas)</code> 的负载均衡场景下，只有当就绪探针返回成功才会将流量路由至该 <code>Pod</code> 节点。</p><p>首先在之前的 <code>Spring Boot</code> 工程中新增健康检测接口，在生产环境中可使用 <code>Actuator</code> 健康检测。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api"</span><span class="token punctuation">)</span><span class="token keyword">public</span> TestResource <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"health"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">health</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"success"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改之前的 <code>test-deployment.yaml</code> 文件，通过 <code>readinessProbe</code> 配置就绪探针策略。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test          <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test<span class="token punctuation">:</span><span class="token number">1.0</span>          <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent          <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>            <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>              <span class="token key atrule">path</span><span class="token punctuation">:</span> /api/health              <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9090</span>            <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>            <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">30</span>            <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>            <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">3</span>            <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">3</span>            <span class="token key atrule">terminationGracePeriodSeconds</span><span class="token punctuation">:</span> <span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>探针配置的类型除了 <code>httpGet</code> 接口外，还支持 <code>tcpSocket</code>、<code>grpc</code> 与 <code>exec</code> 等形式，各项效果类型这里不展开介绍，详细配置可阅览官网教程：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">Container Probes</a>。</p><p>针对探针的其余参数这里列举几项常见配置，详细内容同样参考官网：<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes">Probes Config</a>。</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">参数</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">initialDelaySeconds</td>        <td style="text-align: center;">启动后要等待多少秒后才启动探针。</td>    </tr>    <tr>        <td style="text-align: center;">periodSeconds</td>        <td style="text-align: center;">探测的间隔（单位是秒），默认是 10 秒，最小值是 1。</td>    </tr>    <tr>        <td style="text-align: center;">timeoutSeconds</td>        <td style="text-align: center;">超时后等待多少秒，默认值是 1 秒，最小值是 1。</td>    </tr>    <tr>        <td style="text-align: center;">successThreshold</td>        <td style="text-align: center;">指定探针连续成功多少次才算真的成功，默认值是 1。</td>    </tr>    <tr>        <td style="text-align: center;">failureThreshold</td>        <td style="text-align: center;">探针在失败次数阈值，默认值为 3，最小值为 1。</td>    </tr>    <tr>        <td style="text-align: center;">terminationGracePeriodSeconds</td>        <td style="text-align: center;">被终止时给容器优雅退出的最长等待时间（秒），默认 30 秒。</td>    </tr></table><br/><p>以下述就绪探针配置为例，即在服务启动 <code>10s (initialDelaySeconds)</code> 后启动，每隔 <code>5s (periodSeconds)</code> 进行重试，当响应超过 <code>10s</code> 则为失败。</p><p>若连续 <code>3次 (successThreshold)</code> 成功则表明服务可用，若超过 <code>3次 (failureThreshold)</code> 失败则将触发服务重启，此时向容器发起重启指定并等待 <code>30s (terminationGracePeriodSeconds)</code> ，若此时未能重启成功将执行服务强制重启。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>    <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>    <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>    <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>    <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">3</span>    <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">3</span>    <span class="token key atrule">terminationGracePeriodSeconds</span><span class="token punctuation">:</span> <span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-存活探针"><a href="#2-存活探针" class="headerlink" title="2. 存活探针"></a>2. 存活探针</h4><p>存活探针与就绪探针类似，前者作用于服务运行期间，而后者则生效于服务启动期间。</p><p>存活探针通过 <code>livenessProbe</code> 参数进行配置，其配置方式与上述就绪探针一致这里不在重复介绍。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>deployment<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test          <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>test<span class="token punctuation">:</span><span class="token number">1.0</span>          <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent          <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>            <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>              <span class="token key atrule">path</span><span class="token punctuation">:</span> /api/health              <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9090</span>            <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">3</span>            <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-启动探针"><a href="#3-启动探针" class="headerlink" title="3. 启动探针"></a>3. 启动探针</h4><p>启动探针 <code>(startupProbe)</code> 顾名思义用于指示容器中的应用是否已经启动，若配置了启动探针则所有其他探针都会被禁用，直到此探针成功为止。</p><p>如果启动探测失败，<code>kubelet</code> 将杀死容器，而容器依其重启策略进行重启，若容器没有提供启动探测，则默认状态为 <code>Success</code>。</p><p>在实际的服务部署中，相对上述提到的两类探针服务，启动探针通常并不是我们关心的重点，其使用频率相对前二者也更低。</p><p>同时，其使用与就绪探针和存活探针并无差异，故这里不再介绍，详情可参考官网：<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes">StartupProbe</a>。</p><h3 id="五、Service"><a href="#五、Service" class="headerlink" title="五、Service"></a>五、Service</h3><h4 id="1-服务模式"><a href="#1-服务模式" class="headerlink" title="1. 服务模式"></a>1. 服务模式</h4><p>之前的示例利用 <code>Deployment</code> 启动了多个副本，那对于这多个 <code>Pod</code> 实例 <code>Kubectl</code> 又如何实现流量管理呢？</p><p>答案就是 <code>Service</code>，通过 <code>Service</code> 以及探针 <code>Kubectl</code> 便可实现高精度的流量管理，以更通俗的话来讲，<code>Service</code> 就是 <code>Kubectl</code> 集群内部的 <code>Nginx</code> 管理服务。</p><p>针对不同的服务方式，<code>Service</code> 提供了下述三类资源类型，其中 <code>ClusterIP</code> 与 <code>NodePort</code> 后面会通过具体示例进行介绍，而 <code>LoadBalancer</code> 则为利用各大云服务厂商的负载均衡器对外提供服务，这里便不过多阐述。</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">类型</td>        <th style="text-align: center;">描述</td>    </tr>    <tr>        <td style="text-align: center;">ClusterIP</td>        <td style="text-align: center;">默认，通过集群方式暴露服务。</td>    </tr>    <tr>        <td style="text-align: center;">NodePort</td>        <td style="text-align: center;">使用 K8S 集群节点对外暴露服务。</td>    </tr>    <tr>        <td style="text-align: center;">LoadBalancer</td>        <td style="text-align: center;">使用云提供商的负载均衡器向外部暴露服务。</td>    </tr></table><h4 id="2-ClusterIP"><a href="#2-ClusterIP" class="headerlink" title="2. ClusterIP"></a>2. ClusterIP</h4><p><code>ClusterIP</code> 即传统的集群服务模式，在集群内通过分配虚拟 <code>IP</code> 管理流量，注意这个虚拟 <code>IP</code> 只能被 <code>Pod / Node</code> 内部访问而无法对外提供服务。</p><p>让我们来看由具体的场景作为切入点，设想在 <code>Kubernetes</code> 集群中部署了两个系统，而各自系统都实现了多副本实例，那么两个系统间存在交互那如何通讯使流量能够均匀分步到每个节点便成了关键。</p><p>在这类场景中，可以理解 <code>ClusterIP</code> 为集群内部的负载均衡器，其模糊了系统内部运行细节而将其作为一个整体与集群内其它系统实现服务通讯。<br><img src="/album/loading.gif" data-original="/album/article/linux/k8s/5.png"></p><p>同样的，让我们以来看具体的配置示例，以 <code>ClusterIP</code> 为例新建 <code>test-svc-cluster.yaml</code> 文件如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>svc<span class="token punctuation">-</span>cluster<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9090</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">9090</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>kind: Service</code> 指定服务类型为 <code>service</code>，与之前 <code>Deployment</code> 类似这里通过 <code>spec.selector.app</code> 同样用于配置标签，标识哪些 <code>Pod</code> 被当前 <code>Service</code> 所管理。</p><p>而 <code>targetPort</code> 属性用于将 <code>Pod</code> 实例内的端口 <code>port</code> 进行映射暴露。</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">配置</td>        <th style="text-align: center;">描述</td>    </tr>    <tr>        <td style="text-align: center;">metadata.name</td>        <td style="text-align: center;">指定 Service 名称。</td>    </tr>    <tr>        <td style="text-align: center;">spec.type</td>        <td style="text-align: center;">指定 Service 类型，可选：ClusterIP，NodePort，LoadBalancer。</td>    </tr>    <tr>        <td style="text-align: center;">spec.selector.app</td>        <td style="text-align: center;">指定 Service 所管理的标签组。</td>    </tr>    <tr>        <td style="text-align: center;">spec.ports.port</td>        <td style="text-align: center;">指定 Pod 内的服务端口。</td>    </tr>    <tr>        <td style="text-align: center;">spec.ports.targetPort</td>        <td style="text-align: center;">指定 Service 暴露的服务端口。</td>    </tr></table></br><p>启动 <code>Service</code> 之后可以看到 <code>Kubernetes</code> 为其分配了虚拟 <code>IP = 10.104.110.236</code>。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动 service</span><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl apply -f test-svc.yaml </span>service/test-svc created<span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get svc</span>NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>    AGEkubernetes   ClusterIP   10.96.0.1        <span class="token operator">&lt;</span>none<span class="token operator">></span>        443/TCP    9dtest-svc     ClusterIP   10.104.110.236   <span class="token operator">&lt;</span>none<span class="token operator">></span>        9090/TCP   12s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时通过 <code>get endpoints</code> 命令查看可以看到其成功通过 <code>label</code> 关联之前创建的多个 <code>Pod</code> 节点，在 <code>ENDPOINTS</code> 所列的服务信息也恰好与所创建的 <code>3</code> 个 <code>Pod</code> 实例 <code>IP</code> 相匹配。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get endpoints</span>Warning: v1 Endpoints is deprecated <span class="token keyword">in</span> v1.33+<span class="token punctuation">;</span> use discovery.k8s.io/v1 EndpointSliceNAME         ENDPOINTS                                            AGEkubernetes   192.168.49.2:8443                                    9dtest-svc     10.244.0.23:9090,10.244.0.24:9090,10.244.0.25:9090   24s<span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -o wide</span>NAME                               READY   STATUS    RESTARTS   AGE   IP            NODE       NOMINATED NODE   READINESS GATEStest-deployment-6ccd7f9d44-2chzq   1/1     Running   0          47h   10.244.0.24   minikube   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>test-deployment-6ccd7f9d44-d7sr7   1/1     Running   0          47h   10.244.0.25   minikube   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span>test-deployment-6ccd7f9d44-r8xb7   1/1     Running   0          47h   10.244.0.23   minikube   <span class="token operator">&lt;</span>none<span class="token operator">></span>           <span class="token operator">&lt;</span>none<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们进入 <code>Minikube VM</code> 进行验证，多次请求同一个分配的虚拟 <code>IP</code> 可以看到返回了不同节点的 <code>Hostname</code>，说明 <code>Service</code> 成功实现负载均衡将流量覆盖到集群中的所有节点。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># minikube ssh</span>docker@minikube:~$ curl http://10.104.110.236:9090/api/hellotest-deployment-6ccd7f9d44-2chzq say Hello<span class="token operator">!</span>docker@minikube:~$ curl http://10.104.110.236:9090/api/hellotest-deployment-6ccd7f9d44-d7sr7 say Hello<span class="token operator">!</span>docker@minikube:~$ curl http://10.104.110.236:9090/api/hellotest-deployment-6ccd7f9d44-r8xb7 say Hello<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-NodePort"><a href="#3-NodePort" class="headerlink" title="3. NodePort"></a>3. NodePort</h4><p>正如上述所说的 <code>ClusterIP</code> 所分配的虚拟 <code>IP</code> 并不提供对外服务能力，而服务的对外访问诉求正是通过 <code>NodePort</code> 解决。</p><p>首先让我们来看一下 <code>Node</code> 节点的定义，在之前的示例中基于 <code>replicas</code> 多副本实现了高性能与高可用，但若 <code>Kubernetes</code> 服务自身出现宕机，其内部服务不论再多实例都不起作用。</p><p>因此，实际生产环境中 <code>Kubernetes</code> 同样是以多节点组成的集群的形式存在，而这每个节点称之为 <code>Node</code>。</p><p><code>NodePort</code> 即为 <code>Kubernetes</code> 集群中的每个节点 <code>(Node)</code> 上开一个端口以对外提供访问，<code>K8S</code> 会默认分配端口：<code>30000–32767</code>，访问任意 <code>Node IP + NodePort</code> 都能访问服务。<br><img src="/album/loading.gif" data-original="/album/article/linux/k8s/6.png"></p><p>老规矩还是来看具体的示例，新建 <code>test-svc-np.yaml</code> 配置如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>svc<span class="token punctuation">-</span>np<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>label  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9090</span>      <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">30000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>NodePort</code> 的绝大部分配置与上述 <code>ClusterIP</code> 并无差异，其中 <code>ports.port</code> 指定内网服务端口，而 <code>ports.nodePort</code> 则用于指定对外暴露的端口，需注意这个值可选范围在 <code>30000–32767</code>，若未指定则会随机分配。</p><p>如上述配置中即将内网 <code>9090</code> 服务暴露至 <code>30000</code> 端口，此时便可通过 <code>NodeIP + NodePort</code> 的方式访问服务。</p><p>可以看到此时通过 <code>Node IP</code> 便可访问服务，为临时的服务测试访问提供了通道。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动服务</span><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl apply -f test-svc-np.yaml</span>service/test-svc-np configured<span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get svc</span>NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGEkubernetes    ClusterIP   10.96.0.1        <span class="token operator">&lt;</span>none<span class="token operator">></span>        443/TCP          12dtest-svc-np   NodePort    10.97.183.23     <span class="token operator">&lt;</span>none<span class="token operator">></span>        9090:30000/TCP   2m2s<span class="token comment" spellcheck="true"># 获取 IP</span><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># minikube service test-svc-np --url</span>http://192.168.49.2:30000<span class="token comment" spellcheck="true"># 访问服务</span><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://192.168.49.2:30000/api/hello</span>test-deployment-6ccd7f9d44-d7sr7 say Hello<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>Minikube</code> 与真实宿主机仍然存在一层网络隔离，所以上述的请求都是基于 <code>Minikube VM</code> 服务环境下，若在服务测试时需要将端口临时暴露给宿主机，则可通过 <code>kubectl port-forward</code> 命令。</p><p>如下便将集群内部的 <code>9090</code> 端口临时映射暴露至宿主机 <code>9091</code> 端口，但需注意 <code>port-forward</code> 只是调试隧道并不保证负载均衡能力，建议仅可作用临时调试使用。</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl port-forward svc/test-svc-np 9091:9090 --address 0.0.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-LoadBalancer"><a href="#4-LoadBalancer" class="headerlink" title="4. LoadBalancer"></a>4. LoadBalancer</h4><p><code>LoadBalancer</code> 是基于云厂商的向外部暴露服务，生产环境中更多的采用此类方式。</p><p>在刚刚的 <code>NodePort</code> 示例中，外部访问需求明确知道节点 <code>IP</code>，流量入口永远被固定到指定节点无法实现负载均衡，同时端口也被限制于 <code>30000-32767</code> 之间，对于 <code>Web</code> 服务而言则不符合 <code>80/443</code> 的使用习惯。</p><p>而 <code>LoadBalancer</code> 在启动服务后可获取其 <code>EXTERNAL-IP</code> 实现资源访问，请求将会均匀负载至集群的所有的 <code>Node</code> 上，屏蔽了集群内部网络细节并实现真正意义的负载均衡。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get svc</span>NAME          TYPE           CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGEtest-svc-lb   LoadBalancer   10.106.96.175    <span class="token operator">&lt;</span>pending<span class="token operator">></span>     9090:32322/TCP   8s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于 <code>Minikube</code> 本地集群的原因这里 <code>EXTERNAL-IP</code> 无法正常访问，可通过 <code>tunal</code> 方式实现，详情参考官网：<a href="https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access">loadbalancer-access</a>。</p><p>简而言之，<code>LoadBalancer</code> 才是生产所推荐的服务暴露方式，用于实现对外入口与流量调度器。<br><img src="/album/loading.gif" data-original="/album/article/linux/k8s/9.png"></p><h3 id="六、Ingress"><a href="#六、Ingress" class="headerlink" title="六、Ingress"></a>六、Ingress</h3><h4 id="1-网关服务"><a href="#1-网关服务" class="headerlink" title="1. 网关服务"></a>1. 网关服务</h4><p>在上述的 <code>Service</code> 中通过 <code>ClusterIP</code> 实现了集群内部的流量管理，那又如何实现与外部的通讯交互？同时，集群内多个服务拥有多个 <code>Service</code> 时又该如何高效的进行管理也成了一大问题。</p><p>而这一切的问题都指向同一个答案，那就是：<code>Ingress</code>。</p><p>需要注意的是，<code>Ingress</code> 本身并不提供与集群外部的直接访问功能，而是提供了集群内与外部的路由网关服务。其通过协议配置的机制来解析 <code>URI</code>、主机名称、路径等 <code>Web</code> 等，是统一的 <code>HTTP/HTTPS</code> 流量入口与路由规则层。</p><h4 id="2-配置规则"><a href="#2-配置规则" class="headerlink" title="2. 配置规则"></a>2. 配置规则</h4><p>同样来看具体配置示例，新建 <code>test-ingress.yaml</code> 文件如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> networking.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>ingress  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">nginx.ingress.kubernetes.io/ssl-redirect</span><span class="token punctuation">:</span> <span class="token string">"false"</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">rules</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">http</span><span class="token punctuation">:</span>        <span class="token key atrule">paths</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /api/hello            <span class="token key atrule">pathType</span><span class="token punctuation">:</span> Prefix            <span class="token key atrule">backend</span><span class="token punctuation">:</span>              <span class="token key atrule">service</span><span class="token punctuation">:</span>                <span class="token key atrule">name</span><span class="token punctuation">:</span> test<span class="token punctuation">-</span>svc<span class="token punctuation">-</span>cluster                <span class="token key atrule">port</span><span class="token punctuation">:</span>                  <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">9090</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Ingress</code> 核心配置项说明如下，若需更详细内容可参阅官网文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/">Ingress</a>。</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">参数</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">metadata.name</td>        <td style="text-align: center;">指定 Ingress 名称。</td>    </tr>    <tr>        <td style="text-align: center;">metadata.annotations</td>        <td style="text-align: center;">指定 Ingress 配置指令。</td>    </tr>    <tr>        <td style="text-align: center;">http.paths.path</td>        <td style="text-align: center;">指定网关路由路径。</td>    </tr>    <tr>        <td style="text-align: center;">http.paths.pathType</td>        <td style="text-align: center;">路径配置类型，可选：Exact，Prefix，ImplementationSpecific。</td>    </tr>    <tr>        <td style="text-align: center;">http.paths.backend.service</td>        <td style="text-align: center;">路由所匹配的后端 service 服务。</td>    </tr></table></br><p>其中 <code>annotations</code> 用于 <code>Ingress</code> 控制器配置行为，参考所选择的不同 <code>Ingress</code> 控制器查询其相应文档了解具体配置，如 <code>minikube</code> 默认使用 <a href="https://minikube.sigs.k8s.io/docs/tutorials/nginx_tcp_udp_ingress/">Nginx-Ingress</a> 。</p><p>而 <code>pathType</code> 相对较好理解即路径匹配规则，如最常用的 <code>Exact</code> 与 <code>Prefix</code> 分别代表严格匹配和前缀匹配。</p><p><code>backend</code> 配置项则用于指定当路由规则匹配时的流量转发，如上示例将在匹配 <code>/api/hello</code> 时将流量转发至 <code>test-svc-cluster</code> 的 <code>service</code> 服务。</p><h4 id="3-服务示例-1"><a href="#3-服务示例-1" class="headerlink" title="3. 服务示例"></a>3. 服务示例</h4><p>那么就让我们运行上述的配置示例来查看其效果，注意在 <code>minikube</code> 集群下要使用 <code>Ingress</code> 需要先启动 <code>Ingress-Controller</code> 服务。</p><pre class="line-numbers language-bash"><code class="language-bash">minikube addons <span class="token function">enable</span> ingress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过 <code>apply -f</code> 启动后可以看到服务正常并监听 <code>80</code> 端口。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl apply -f test-ingress.yaml</span><span class="token comment" spellcheck="true"># ingress.extensions/test-ingress created</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get ingress</span>NAME           CLASS   HOSTS   ADDRESS   PORTS   AGEtest-ingress   nginx   *                 80      10s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如刚刚提到 <code>Ingress</code> 并不提供服务访问能力而是作为网关路由，所以要访问需要借助 <code>NodePort</code> 实现。</p><p>刚才提到了 <code>minikube</code> 默认使用 <code>Nginx-Ingress</code>，其在对应命名下空间下提供了默认 <code>NodePort</code> 服务 <code>ingress-nginx-controller</code>。</p><p>通过 <code>--url</code> 便可获取其对应的访问地址，其中第一个是 <code>32666</code> 对应 <code>80</code> 端口即 <code>HTTP</code> 服务，第二个相对应的 <code>HTTPS</code> 服务。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get svc -n ingress-nginx</span>NAME                                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>                      AGEingress-nginx-controller             NodePort    10.106.147.226   <span class="token operator">&lt;</span>none<span class="token operator">></span>        80:32666/TCP,443:30206/TCP   1hingress-nginx-controller-admission   ClusterIP   10.106.174.196   <span class="token operator">&lt;</span>none<span class="token operator">></span>        443/TCP                      1h<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># minikube service ingress-nginx-controller -n ingress-nginx --url</span>http://192.168.49.2:32666http://192.168.49.2:30206<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取服务访问信息之后，便可通过此 <code>IP</code> 请求服务，可以看到成功实现负载均衡请求。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://192.168.49.2:32666/api/hello</span>test-deployment-75ff6944d7-kfjcd say Hello<span class="token operator">!</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://192.168.49.2:32666/api/hello</span>test-deployment-75ff6944d7-zllwl say Hello<span class="token operator">!</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># curl http://192.168.49.2:32666/api/hello</span>test-deployment-75ff6944d7-vqx95 say Hello<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-优势差异"><a href="#4-优势差异" class="headerlink" title="4. 优势差异"></a>4. 优势差异</h4><p>看到这你或许有个疑问，说到底这不是还是通过 <code>NodePort</code> 访问服务吗？那跟直接 <code>Service</code> 又有什么区别？</p><p>下面让我们以具体的场景进行介绍 <code>Ingress</code> 其核心竞争力到底在哪？</p><p>假设当前集群存在 <code>3</code> 个不同的系统集群 <code>Service-1</code>、<code>Service-2</code> 与 <code>Service-3</code>，通过 <code>NodePort</code> 方式对外提供服务，即存在 <code>9091:30001</code>、<code>9092:30002</code> 与 <code>9093:30003</code>，示意图如下：<br><img src="/album/loading.gif" data-original="/album/article/linux/k8s/7.png"></p><p>通过图示可以看到服务器需要对外暴露三个端口，与之相对应防火墙我们也许配置三套规则规则。而在企业环境中服务数量往往及其庞大，那么其管理成本也将陡升。</p><p>那么 <code>Ingress</code> 其优势显而易见，将上述的场景通过 <code>Ingress</code> 改造后图示如下，集群只需对外暴露一个端口即可，提高安全性的同时维护成本也大大降低。</p><p>即便抛开这一切不谈，<code>Ingress</code> 所提供的 <code>SSL/TLS</code> 与域名服务解析等等能力也是 <code>Service</code> 所不具备。<br><img src="/album/loading.gif" data-original="/album/article/linux/k8s/8.png"></p><h3 id="七、命名空间"><a href="#七、命名空间" class="headerlink" title="七、命名空间"></a>七、命名空间</h3><h4 id="1-基础介绍-2"><a href="#1-基础介绍-2" class="headerlink" title="1. 基础介绍"></a>1. 基础介绍</h4><p>和所有的应用一样，通常在一套集群下我们会部署多个环境服务，因此环境隔壁也在服务部署中也必不可少。</p><p>而在 <code>Kubernetes</code> 中一样提供了命名空间 <code>namespace</code> 用于实现环境隔离。</p><p>默认下所有的操作都在 <code>default</code> 命名空间下，通过 <code>get namespace</code> 可以查看当前所有命名空间。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get namespace</span>NAME                   STATUS   AGEdefault                Active   9dingress-nginx          Active   9m39skube-node-lease        Active   9dkube-public            Active   9dkube-system            Active   9dkubernetes-dashboard   Active   3d7h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而 <code>namespace</code> 的创建相对之前可谓十分简单，新建 <code>namespace-dev.yaml</code> 文件如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Namespace<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>完成后同样通过 <code>apply -f</code> 创建，而 <code>namespace</code> 的使用也并不复杂，在命令中通过 <code>-n</code> 指定便可。</p><p>例如下述命令默认查询 <code>default</code> 下的所有 <code>pod</code> 节点:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若需要查询刚刚创建的 <code>dev</code> 命名空间通过 <code>-n dev</code> 即可：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost app<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># kubectl get pod -n dev</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在之前的文章中我们分享了 &lt;code&gt;Docker&lt;/code&gt; 与 &lt;code&gt;Docker Compose&lt;/code&gt; 的使用，前者通过容器化技术简化了服务管理，而后者则提供 &lt;code&gt;YAML&lt;/code&gt; 方式进一步简化 &lt;code&gt;Docker&lt;/code&gt; </summary>
      
    
    
    
    <category term="Linux运维" scheme="https://budai.pages.dev/categories/Linux%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Docker" scheme="https://budai.pages.dev/tags/Docker/"/>
    
    <category term="Kubernetes" scheme="https://budai.pages.dev/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>事件发布模型剖析</title>
    <link href="https://budai.pages.dev/java/design/event/"/>
    <id>https://budai.pages.dev/java/design/event/</id>
    <published>2025-11-30T16:00:00.000Z</published>
    <updated>2025-12-01T14:06:09.364Z</updated>
    
    <content type="html"><![CDATA[<p>异步是编程中的一大核心思想，在提升项目代码质量以及系统服务性能中扮演重要角色。</p><p>而实现异步的途径可谓五花八门，不论是最基础的线程异步，亦或借助消息队列等第三方服务，都可实现异步解耦的效果。</p><p>今天，则让我们聚焦于 <code>Spring</code> 框架为我们所提供的事件发布功能，实现优雅的代码异步操作。</p><h4 id="1-模型介绍"><a href="#1-模型介绍" class="headerlink" title="1. 模型介绍"></a>1. 模型介绍</h4><p>在开始具体的介绍前先让我们看一下在传统的调用链路中是如何实现方法执行。</p><p>假设存在 <code>MyService</code> 服务类且需要在 <code>MyTest</code> 类中调用服务方法，最简单的方式即通过 <code>new</code> 声明对象后进行调用，如下代码所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyService service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        service<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从代码可以看出，测试类 <code>MyTest</code> 显然强依赖于服务类 <code>MyService</code>。让我们继续放大这一特点，如果将两个类分别比作两个独立的系统，同理两个系统则高度耦合。</p><p>应对此类场景，通常才引入第三方存在如队列等容器，生产者将数据入队后由消费者操作出队读取数据，模块间不再由强关联，这便是服务解耦的理念。</p><h4 id="2-事件声明"><a href="#2-事件声明" class="headerlink" title="2. 事件声明"></a>2. 事件声明</h4><p>秉持着相同的理念，<code>Spring</code> 提供了 <code>ApplicationEvent</code> 支持事件的发布与监听，从而实现代码流程异步。</p><p><code>Spring</code> 事件发布模型中设计三个核心概念：发布者、事件、监听器。如果你熟悉消息队列等中间件服务，针对这些名词想必早已耳熟目染。</p><p>其中发布者与监听器故名思意即数据的生产者与消费者，而事件则可理解为这一过程所传递的数据内容。</p><p>那么就让我们以最直观的代码示例进行演示，以数据广播推送场景为例，声明 <code>BroadcastContext</code> 上下文用于携带事件数据。同时新建事件类继承于 <code>ApplicationEvent</code> 事件服务类，代码并不复杂具体如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 数据载体</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BroadcastContext</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String content<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 事件定义</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BroadcastEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">BroadcastEvent</span><span class="token punctuation">(</span>BroadcastContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而完成事件的定义之后便可通过生产者发布事件，在 <code>Spring</code> 工程中使用也及其简单，注入 <code>ApplicationEventPublisher</code> 实例后通过 <code>publishEvent()</code> 服务方法即可发布事件。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token annotation punctuation">@RequiredArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BroadcastResources</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ApplicationEventPublisher publisher<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">publish</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 构建上下文</span>        BroadcastContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroadcastContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">setContent</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 事件发布</span>        publisher<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BroadcastEvent</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-事件监听"><a href="#3-事件监听" class="headerlink" title="3. 事件监听"></a>3. 事件监听</h4><p>既然有事件发布则必然也存在消费监听器，与 <code>ApplicationEvent</code> 相对应的通过 <code>ApplicationListener</code> 实现事件的监听。</p><p>根据上述定义的事件发布者，其相对应的事件监听器定义如下，在 <code>onApplicationEvent()</code> 服务方法中则可定义具体的事件消费处理逻辑。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@RequiredArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BroadcastListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token operator">&lt;</span>BroadcastEvent<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@TransactionalEventListener</span><span class="token punctuation">(</span>phase <span class="token operator">=</span> TransactionPhase<span class="token punctuation">.</span>AFTER_COMMIT<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span>BroadcastEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取上下文</span>        BroadcastContext context <span class="token operator">=</span> <span class="token punctuation">(</span>BroadcastContext<span class="token punctuation">)</span> event<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// TODO 数据处理</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需注意一点，在 <code>ApplicationEvent</code> 事件发布模型下整个过程流程上仍处理同步事务，即事件的发布与监听消费仍处于同一线程中，所实现的效果仅仅是代码异步接口。</p><p>如果想要实现流程逻辑上的异步，则可在上述的 <code>onApplicationEvent()</code> 服务方法上搭配 <code>@Async</code> 注解实现异步。</p><p>正是因为流程仍是同步的关系，在数据库事务场景下，如若监听器逻辑事务无关且流程耗时，可通过 <code>@TransactionalEventListener</code> 注解配置监听器的触发时机。当监听器服务方法开启注解后，默认在会数据库事务提交后触发，避免长事务所带来的性能损耗。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;异步是编程中的一大核心思想，在提升项目代码质量以及系统服务性能中扮演重要角色。&lt;/p&gt;
&lt;p&gt;而实现异步的途径可谓五花八门，不论是最基础的线程异步，亦或借助消息队列等第三方服务，都可实现异步解耦的效果。&lt;/p&gt;
&lt;p&gt;今天，则让我们聚焦于 &lt;code&gt;Spring&lt;/cod</summary>
      
    
    
    
    <category term="设计模式" scheme="https://budai.pages.dev/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="JAVA" scheme="https://budai.pages.dev/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Python环境编译构建</title>
    <link href="https://budai.pages.dev/pyhton/install/"/>
    <id>https://budai.pages.dev/pyhton/install/</id>
    <published>2025-11-16T16:00:00.000Z</published>
    <updated>2025-11-19T11:25:19.169Z</updated>
    
    <content type="html"><![CDATA[<p>和常见的开发环境如 <code>JDK</code> 一样，若需运行服务同样需要安装 <code>Python</code> 运行环境，下面就让我们分别了解在 <code>Windows</code> 与 <code>Linux</code> 环境下如何安装 <code>Python</code> 环境。</p><h3 id="一、Windows"><a href="#一、Windows" class="headerlink" title="一、Windows"></a>一、Windows</h3><h4 id="1-应用安装"><a href="#1-应用安装" class="headerlink" title="1. 应用安装"></a>1. 应用安装</h4><p>在 <code>Windows</code> 环境下 <code>Python</code> 安装极为简单，进入官网后按需下载对应的版本即可，<a href="https://www.python.org/downloads/">官网直达</a>。<br><img src="/album/loading.gif" data-original="/album/article/python/module/1.png"></p><p>如果上述地址访问较慢，可尝试通过阿里镜像地址进行下载安装。</p><pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">https:</span>//npm.taobao.org/mirrors/python/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载后具体安装步骤比较简单，无脑下一步即可这里就不过多介绍，完成后默认安装路径在：<code>C:\Users\&lt;username&gt;\AppData\Local\Programs\Python</code> 下。</p><h3 id="二、Openssl"><a href="#二、Openssl" class="headerlink" title="二、Openssl"></a>二、Openssl</h3><h4 id="1-环境依赖"><a href="#1-环境依赖" class="headerlink" title="1. 环境依赖"></a>1. 环境依赖</h4><p>在 <code>Linux</code> 环境下安装 <code>Python</code> 时需注意 <code>3.9</code> 之后的版本不再自带 <code>openssl</code> 依赖库，而 <code>CentOS 7</code> 中默认为 <code>1.0.2</code> 版本过低在高版本 <code>Python</code> 环境下通常无法兼容。</p><p>因此，在对于 <code>3.9</code> 以上版本需要手动升级安装 <code>Openssl</code> 依赖，按下述步骤执行。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载依赖包</span><span class="token function">wget</span> https://www.openssl.org/source/old/1.1.1/openssl-1.1.1.tar.gz<span class="token comment" spellcheck="true"># 解压依赖包</span><span class="token function">tar</span> -zxvf openssl-1.1.1.tar.gz<span class="token function">cd</span> openssl-1.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解压完成后对服务包进行编译构建，需注意编译涉及 <code>gcc</code> 工具，若无可通过 <code>yum</code> 进行下载。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 依赖下载</span>yum <span class="token function">install</span> -y gcc<span class="token comment" spellcheck="true"># 编译构建</span>./config --prefix<span class="token operator">=</span>/usr/local/openssl<span class="token function">make</span> <span class="token operator">&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成上述命令后便会生成 <code>/usr/local/openssl</code> 目录，通过下述命令查看版本：</p><pre class="line-numbers language-bash"><code class="language-bash">/usr/local/openssl/bin/openssl version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-服务验证"><a href="#2-服务验证" class="headerlink" title="2. 服务验证"></a>2. 服务验证</h4><p>若显示 <code>1.1.1</code> 则说明编译安装成功，若提示 <code>error while loading shared libraries xxx</code> 则执行下述命令：</p><p>即通过 <code>export</code> 命令将 <code>openssl</code> 目录写入 <code>LD_LIBRARY_PATH</code> 环境变量。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 添加临时变量</span><span class="token function">export</span> LD_LIBRARY_PATH<span class="token operator">=</span>/usr/local/openssl/lib:<span class="token variable">$LD_LIBRARY_PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述操作仅添加临时变量，系统重启后将会失败，若需永久生效则需通过下述命令写入配置。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 写入系统配置</span><span class="token keyword">echo</span> <span class="token string">"/usr/local/openssl/lib"</span> <span class="token operator">></span> /etc/ld.so.conf.d/openssl-3.confldconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>完成后可再次执行 <code>version</code> 命令验证是否安装成功。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看版本</span>/usr/local/openssl/bin/openssl version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-软链创建"><a href="#3-软链创建" class="headerlink" title="3. 软链创建"></a>3. 软链创建</h4><p>系统默认 <code>openssl</code> 服务目录位于 <code>/usr/local/bin/openssl</code>，为了更方便使用无需每次指定完成路径可为新安装服务创建软链关联。</p><p>若只需临时生效，则同样可通过添加临时变量方式实现，命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">export</span> PATH<span class="token operator">=</span>/usr/local/bin:<span class="token variable">$PATH</span><span class="token function">ln</span> -s /usr/local/openssl/bin/openssl /usr/local/bin/openssl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若需永久生效即重启系统后仍能生效则可写入配置文件。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">'export PATH=/usr/local/bin:<span class="token variable">$PATH</span>'</span> <span class="token operator">>></span> ~/.bashrc<span class="token function">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="三、GCC环境"><a href="#三、GCC环境" class="headerlink" title="三、GCC环境"></a>三、GCC环境</h3><h4 id="1-YUM升级"><a href="#1-YUM升级" class="headerlink" title="1. YUM升级"></a>1. YUM升级</h4><p>在高版本环境中安装第三方类库时常需要 <code>GCC</code> 依赖，而 <code>CentOS 7</code> 中默认版本为 <code>4.8.5</code>，但第三方库编译通常要求 <code>9+</code> 版本。</p><p>因此，除 <code>Openssl</code> 升级之外还需要升级 <code>GCC</code> 版本，版本升级则可通过 <code>YUM</code> 命令进行升级。</p><p>但在 <code>CentOS 7.9</code> 版本之后默认已经停更下载镜像，因此在需要手动更换镜像地址。</p><p>进入 <code>/etc/yum.repos.d/</code> 目录分别修改 <code>CentOS-SCLo-scl.repo</code> 和 <code>CentOS-SCLo-scl-rh.repo</code> 文件。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /etc/yum.repos.d/<span class="token function">vi</span> CentOS-SCLo-scl.repo<span class="token function">vi</span> CentOS-SCLo-scl-rh.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>依次编辑两份文件内容，注释 <code>mirrorlist</code> 内容，将 <code>baseurl</code> 取消注释并替换为阿里云镜像地址，两个文件按照同样步骤执行。</p><pre class="line-numbers language-txt"><code class="language-txt">baseurl=https://mirrors.aliyun.com/centos/7/sclo/$basearch/sclo/#mirrorlist=https://mirrorlist.centos.org?arch=$basearch&release=7&repo=sclo-sclo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-GCC升级"><a href="#2-GCC升级" class="headerlink" title="2. GCC升级"></a>2. GCC升级</h4><p>在替换 <code>YUM</code> 镜像服务后便可升级 <code>GCC</code> 版本，执行下述命令升级。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 依赖下载</span>yum <span class="token function">install</span> -y centos-release-sclyum <span class="token function">install</span> -y devtoolset-11<span class="token comment" spellcheck="true"># 激活 GCC 11</span>scl <span class="token function">enable</span> devtoolset-11 <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装成功后可通过 <code>version</code> 参数查看版本信息：</p><pre class="line-numbers language-bash"><code class="language-bash">gcc --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样的，如果需要永久生效则通过下述命令写入系统文件：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"source /opt/rh/devtoolset-11/enable"</span> <span class="token operator">>></span> ~/.bashrc<span class="token function">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="四、Linux环境"><a href="#四、Linux环境" class="headerlink" title="四、Linux环境"></a>四、Linux环境</h3><h4 id="1-服务编译"><a href="#1-服务编译" class="headerlink" title="1. 服务编译"></a>1. 服务编译</h4><p>至此则可开始具体的 <code>Python</code> 编译，在具体编译开始前安装相关所需的依赖工具，命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">yum groupinstall -y <span class="token string">"Development tools"</span>yum <span class="token function">install</span> -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-develyum <span class="token function">install</span> -y libffi-devel <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从 <code>Windows</code> 一样从官网下载二进制文件编译安装，完成后同上在官网中选择所需版本文件，上传至服务器后解压，按照下述步骤执行命名。</p><p>其中 <code>--prefix</code> 为文件目录输出路径，<code>--openssldir</code> 则为指定系统中已安装的 <code>openssl</code> 服务目录。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建安装目录</span><span class="token function">mkdir</span> /usr/local/python3<span class="token function">cd</span> Python-3.11.0<span class="token comment" spellcheck="true"># 服务配置</span>./configure \    --prefix<span class="token operator">=</span>/usr/local/python311 \    --with-openssl<span class="token operator">=</span>/usr/local/openssl \    --with-openssl-rpath<span class="token operator">=</span>auto \    --enable-optimizations<span class="token comment" spellcheck="true"># 服务编译</span><span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译结束后便会在 <code>/usr/local/python3</code> 生成目录，创建软链接后即可。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ln</span> -s /usr/local/python311/bin/python3 /usr/local/bin/python3<span class="token function">ln</span> -s /usr/local/python311/bin/pip3 /usr/local/bin/pip3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>完成软链后便可通过 <code>python3</code> 命令验证版本查看是否安装成功。</p><pre class="line-numbers language-bash"><code class="language-bash">python3 -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过下述命令可查看 <code>Python</code> 所使用 <code>openssl</code> 版本，若为 <code>1.1.1</code> 则表示成功。</p><pre class="line-numbers language-bash"><code class="language-bash">/usr/local/python311/bin/python3.11 -c <span class="token string">"import _ssl; print(_ssl.OPENSSL_VERSION)"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;和常见的开发环境如 &lt;code&gt;JDK&lt;/code&gt; 一样，若需运行服务同样需要安装 &lt;code&gt;Python&lt;/code&gt; 运行环境，下面就让我们分别了解在 &lt;code&gt;Windows&lt;/code&gt; 与 &lt;code&gt;Linux&lt;/code&gt; 环境下如何安装 &lt;code&gt;P</summary>
      
    
    
    
    <category term="Python" scheme="https://budai.pages.dev/categories/Python/"/>
    
    
    <category term="Python" scheme="https://budai.pages.dev/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JMeter性能压测教程</title>
    <link href="https://budai.pages.dev/app/jmeter/"/>
    <id>https://budai.pages.dev/app/jmeter/</id>
    <published>2025-11-02T16:00:00.000Z</published>
    <updated>2025-11-03T14:36:10.318Z</updated>
    
    <content type="html"><![CDATA[<p>在应用接口服务开发中，常涉及 <code>TPS(吞吐量)</code> 与 <code>QPS(每秒查询数)</code> 等参数指标，可直观的了解接口性能的优劣。</p><p>而在接口压测中，<code>JMeter</code> 绝对是称得上为神器，其为 <code>Apache</code> 旗下开源的接口测试工具，提供了一系列丰富的操作可协助开发者从各个维度衡量接口性能。</p><p>下面就让我们一同了解如何使用 <code>JMeter</code> 工具对接口服务进行性能测试。</p><h3 id="一、基础面板"><a href="#一、基础面板" class="headerlink" title="一、基础面板"></a>一、基础面板</h3><h4 id="1-应用安装"><a href="#1-应用安装" class="headerlink" title="1. 应用安装"></a>1. 应用安装</h4><p>在开始前进入 <code>JMeter</code> 官网下载对应的应用程序，<a href="https://jmeter.apache.org/download_jmeter.cgi">官网直达</a>。<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/1.png"></p><p>以 <code>Windows</code> 环境为例，解压下载后的文件，双击 <code>bin/jmeter.bat</code> 文件便可启动程序。</p><p>启动后会弹出命名窗口注意不要关闭，之后便可看到如下页面：<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/2.png"></p><h4 id="2-并发模拟"><a href="#2-并发模拟" class="headerlink" title="2. 并发模拟"></a>2. 并发模拟</h4><p>JMeter 的网络请求均基于线程组，因此需要先添加线程用户组，按下图路径进行创建。<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/3.png"></p><p>添加后便可看到下图内容，这边涉及到三个重要参数。</p><h5 id="1-Number-of-Threads-Users"><a href="#1-Number-of-Threads-Users" class="headerlink" title="(1) Number of Threads(Users)"></a>(1) Number of Threads(Users)</h5><p>用于模拟控制并发数量，例如配置为 <code>5</code> 则为模拟 <code>5</code> 名用户同时执行操作。</p><h5 id="2-Ramp-up-period-seconds"><a href="#2-Ramp-up-period-seconds" class="headerlink" title="(2) Ramp-up period(seconds)"></a>(2) Ramp-up period(seconds)</h5><p>用于控制不同并发用户之间的发起间隔。</p><p>如配置为 <code>0</code> 则表示瞬时同时启动 <code>n</code> 个线程发起操作，若配置为 <code>1</code> 则表示每隔 <code>1s</code> 启动一个线程直至并发数量达到 <code>Number of Threads(Users)</code> 所配置值。</p><h5 id="3-Loop-Count"><a href="#3-Loop-Count" class="headerlink" title="(3) Loop Count"></a>(3) Loop Count</h5><p>用于控制每个线程执行操作的次数，若选择 <code>Infinite</code> 则表示无限制循环请求，常用于测试性能瓶颈。</p><p>如配置为 <code>1</code> 则表示每个线程只会操作一次请求，相对应配置为 <code>n</code> 则表示每个线程都会重复操作 <code>n</code> 次。</p><p>例如下图示例即为在 <code>1s</code> 后启动 <code>1</code> 个线程并执行 <code>1</code> 次请求操作。<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/4.png"></p><h4 id="3-网络请求"><a href="#3-网络请求" class="headerlink" title="3. 网络请求"></a>3. 网络请求</h4><p>在添加线程组之后便可创建具体的操作事项，通过下述路径创建 <code>HTTP Request</code> 用于网络请求。<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/5.png"></p><p>添加完成之后便可看到下述页面，填写具体接口地址信息即可，内容并不复杂此处并不详细展开描述。<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/6.png"></p><h4 id="4-请求配置"><a href="#4-请求配置" class="headerlink" title="4. 请求配置"></a>4. 请求配置</h4><p>在许多请求场景中，常需要添加认证信息等请求头信息，在面板中按下述路径添加 <code>HTTP Header Manager</code> 用于配置服务请求头。<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/7.png"></p><p>同样的，完成之后便可按 <code>Key - Value</code> 形式添加请求头信息。<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/8.png"></p><h3 id="二、结果分析"><a href="#二、结果分析" class="headerlink" title="二、结果分析"></a>二、结果分析</h3><h4 id="1-执行结果"><a href="#1-执行结果" class="headerlink" title="1. 执行结果"></a>1. 执行结果</h4><p>完成上述配置项之后，此时还并不能执行具体的请求测试，还需添加结果集。</p><p>按照下图中路径添加 <code>View Results Tree</code> 用于接收以及展示接口响应内容。<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/9.png"></p><p>现在则可以执行发起具体的请求操作，按图示启动后便可看见响应结果。<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/10.png"></p><h4 id="2-汇总分析"><a href="#2-汇总分析" class="headerlink" title="2. 汇总分析"></a>2. 汇总分析</h4><p>上述的所有操作仍然只是基础的接口请求，而 <code>JMeter</code> 真正强大之处不仅可模拟并发，其提供了一系列面板支持输出具体的报告信息。</p><p>在应用中按照下述添加 <code>Summary Report</code> 用于统计请求结果。<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/11.png"></p><p>添加之后修改之前的线程组配置，模拟 <code>10</code> 个线程并发，每个线程发起单次操作。<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/12.png"></p><p>完成之后再次启动运行，通过 <code>Summary Report</code> 可以看到这 <code>10</code> 次的总体效率内容。</p><p>其中 <code>Average</code>，<code>Min</code> 与 <code>Max</code> 分别代表本批请求中平均耗时、最短以及最大耗时，单位为毫秒。<br><img src="/album/loading.gif" data-original="/album/article/tool/jmeter/13.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在应用接口服务开发中，常涉及 &lt;code&gt;TPS(吞吐量)&lt;/code&gt; 与 &lt;code&gt;QPS(每秒查询数)&lt;/code&gt; 等参数指标，可直观的了解接口性能的优劣。&lt;/p&gt;
&lt;p&gt;而在接口压测中，&lt;code&gt;JMeter&lt;/code&gt; 绝对是称得上为神器，其为 &lt;code</summary>
      
    
    
    
    <category term="开发工具" scheme="https://budai.pages.dev/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="HTTP" scheme="https://budai.pages.dev/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>查询调优进阶教程</title>
    <link href="https://budai.pages.dev/db/optimize/"/>
    <id>https://budai.pages.dev/db/optimize/</id>
    <published>2025-10-08T16:00:00.000Z</published>
    <updated>2025-10-13T12:13:16.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h3><h4 id="1-回表查询"><a href="#1-回表查询" class="headerlink" title="1. 回表查询"></a>1. 回表查询</h4><p>在过往介绍 <code>MySQL</code> 聚簇索引时曾提过，当执行查询时会先匹配索引，再通过回表的方式二次匹配具体记录值。<br><img src="/album/loading.gif" data-original="/album/article/db/mysql/index/2.png"></p><p>基于此特性，若想取得更优的查询效率则需减少查询回表次数，便可在查询时可为需返回字段的适当添加索引，减少回表从而提升性能。</p><p>如下述执行计划中查询用户表记录，可以看到通过主键索引正常匹配数据。<br><img src="/album/loading.gif" data-original="/album/article/db/mysql/optimize/1.png"></p><p>调整上述查询语句仅返回单个索引列，即结果列 <code>id</code> 在条件查询 <code>id=1</code> 时已完成匹配，无需回表查询其余信息，可看到此时 <code>Extra=Using index</code> 无需回表查询。</p><p>因此，两个例子中通过执行计划可以看到虽然都命中了主键索引，但第二个查询语句性能仍优于第一个。这也是常提到的查询语句中不建议采用 <code>select *</code> 的原因之一，通过减少返回的属性集从而尽可能减少回表的频次。<br><img src="/album/loading.gif" data-original="/album/article/db/mysql/optimize/2.png"></p><h3 id="二、关联查询"><a href="#二、关联查询" class="headerlink" title="二、关联查询"></a>二、关联查询</h3><h4 id="1-驱动表"><a href="#1-驱动表" class="headerlink" title="1. 驱动表"></a>1. 驱动表</h4><p>在多表 <code>join</code> 关联查询中涉及一个核心概念：驱动表 <code>(Drivering Table)</code>，其对性能起着至关重要的作用。</p><p>所谓驱动表即为关联主表，在 <code>left join</code> 中左表一定为驱动表，在 <code>right join</code> 中则右表为驱动表，而 <code>inner join</code> 中驱动表的选择则由数据库动态决定。</p><p>对于 <code>inner join</code> 而言驱动表的选择遵循着一个质朴的原则：<strong>小表驱动大表</strong>，简而言之，即 <code>inner join</code> 中优化器会初步计算代价有限将小表作为驱动表。</p><p>如存在 <code>tb_class</code> 与 <code>tb_student</code> 两张表数据，其中 <code>tb_student</code> 表量级大于 <code>tb_class</code>，那么在 <code>inner join</code> 查询时无论谁作为主表最终优化器执行永远都是由 <code>tb_class</code> 作为驱动表。</p><p>即下述两个查询语句中驱动表都是 <code>tb_class</code>，可通过执行计划 <code>ID</code> 顺序验证结论。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span>   <span class="token operator">*</span> <span class="token keyword">from</span> tb_class <span class="token number">c</span><span class="token keyword">join</span> tb_student s<span class="token keyword">on</span> s<span class="token punctuation">.</span>class_id <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>id<span class="token keyword">select</span>   <span class="token operator">*</span> <span class="token keyword">from</span> tb_student s<span class="token keyword">join</span> tb_class <span class="token number">c</span><span class="token keyword">on</span> <span class="token number">c</span><span class="token punctuation">.</span>id <span class="token operator">=</span> s<span class="token punctuation">.</span>class_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么为什么 <code>MySQL</code> 会采取这个策略呢？</p><p>在 <code>MySQL</code> 中多表 <code>JOIN</code>（尤其是 <code>Nested Loop Join</code>）有一个执行顺序：先由驱动表取一行，再由其从被驱动表根据连接条件查找匹配。从这个规则路径下可以看出，驱动表是循环次数的控制者。</p><p>按照此规则，可以轻易得到关联的 <code>总成本 = 驱动表行数 * 被驱动扫描行数</code>。而 join 条件通常能通过索引等手段提升性能，即降低驱动表行数从而降低整个查询过程的扫描次数，进而降低 <code>IO</code> 操作次数从而取得更优效率。</p><p>同时，小表作为驱动表的另一好处即提高了缓存命中率。由于 <code>Buffer Pool</code> 缓存池的存在，对于小表可完成被缓冲池缓存。当小表作为驱动表时，每次循环访问小表行都能命中缓冲池，无需频繁磁盘 <code>IO</code>。</p><p>因此，即便在 <code>left join</code> 与 <code>right join</code> 等固定驱动表查询下，也常考虑小表作为驱动表从而提升性能。</p><h4 id="2-驱动代价"><a href="#2-驱动代价" class="headerlink" title="2. 驱动代价"></a>2. 驱动代价</h4><p>从上述的描述可以知道表的记录数是确定确定表的一大关键因素，但其后背蕴含着完整的一套机制。</p><p>除了已经提到的行数指标外，驱动表的确定同时参考下述各项指标：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">优化指标</td>        <th style="text-align: center;">含义</td>    </tr>    <tr>        <td style="text-align: center;">行数估算（rows）</td>        <td style="text-align: center;">表或索引扫描后预计产生的行数。</td>    </tr>    <tr>        <td style="text-align: center;">过滤率（filtered）</td>        <td style="text-align: center;">过滤后剩余比例。</td>    </tr>    <tr>        <td style="text-align: center;">连接代价（join_cost）</td>        <td style="text-align: center;">当前表被扫描后与前面已驱动表连接的开销。</td>    </tr>    <tr>        <td style="text-align: center;">索引可用性</td>        <td style="text-align: center;">是否能用索引进行过滤。</td>    </tr>    <tr>        <td style="text-align: center;">排序或分组代价</td>        <td style="text-align: center;">若有 ORDER BY 或 GROUP BY，是否可顺序扫描。</td>    </tr></table></br><p>以过滤率为例，优化器会根据查询条件预判断，通过过滤后匹配度越高的其作为驱动表的概率越大。</p><p>同样以上述的 <code>tb_class</code> 与 <code>tb_student</code> 为例，表 <code>tb_student</code> 量级大于 <code>tb_class</code>，按常理下在 <code>join</code> 关联查询时优化器将优先考虑 <code>tb_class</code> 作为驱动表。但若查询条件能够更精准的匹配被驱动表，此时情况将发生反转。</p><p>如下查询语句中，通过查询条件 <code>student_id = 1</code> 匹配后 <code>tb_student</code> 仅匹配单条记录，若作为驱动表只需再单次匹配 <code>tb_class</code> 即可完成查询。因此，此场景下 <code>tb_student</code> 便会升阶作为驱动表。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span>   <span class="token operator">*</span> <span class="token keyword">from</span> tb_class <span class="token number">c</span><span class="token keyword">join</span> tb_student s<span class="token keyword">on</span> s<span class="token punctuation">.</span>class_id <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>id<span class="token keyword">where</span>     s<span class="token punctuation">.</span>student_id <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-驱动特例"><a href="#3-驱动特例" class="headerlink" title="3. 驱动特例"></a>3. 驱动特例</h4><p>虽然优化器有着一套完善的机制，但并非在所有情况下其都能够给出最优解。</p><p>在 <code>join</code> 查询确定驱动表时，将优先以小表作为驱动表进行关联查询。但若两张表差距过于悬殊时，大表驱动小表往往却能展现出更优的效率。</p><p>让我们以伪代码的角度来分析 <code>join</code> 的执行流程，在 <code>InnoDB</code> 的嵌套循环连接 <code>(Nested Loop Join)</code> 中，执行器以驱动表 <code>outer_table</code> 为关联遍历被驱动表 <code>inner_table</code>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">for</span> each row in outer_table    find matching rows in <span class="token function">inner_table</span> <span class="token punctuation">(</span>using index <span class="token keyword">if</span> possible<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>按照小表驱动大表的规则，小表中每条记录都需通过索引循环匹配大表记录，频繁的索引定位及回表操作将严重拖慢查询效率。</p><p>反之这类场景下若以大表驱动小表，则只需大表执行一次全量扫描，对于小表的匹配关联在索引下执行效率反而更高。</p><p>故此，<strong>小表驱动大表并非万能铁律，优化的核心关键在于降低查询扫描次数</strong>，减少 <code>IO</code> 从而提升效率。</p><p>此类场景，若想跳过优化器的介入，则可通过 <code>STRAIGHT_JOIN</code> 强制优化器按照语句定义的顺序进行查询，即定义在前的永远的是驱动表。</p><p>调整刚刚的查询语句，如下示例中优化器将不再作任何操作，由于 <code>tb_class</code> 定义在前则以其作为驱动表执行查询。故此，对于上述提到的负优化，则可手动指定关联的驱动表。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span>   <span class="token operator">*</span> <span class="token keyword">from</span> tb_class <span class="token number">c</span>straight_join tb_student s<span class="token keyword">on</span> s<span class="token punctuation">.</span>class_id <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、查询优化"><a href="#三、查询优化" class="headerlink" title="三、查询优化"></a>三、查询优化</h3><h4 id="1-Semi优化"><a href="#1-Semi优化" class="headerlink" title="1. Semi优化"></a>1. Semi优化</h4><p>在索引失效的场景中，否定查询如 <code>not in</code> 或 <code>!=</code> 等操作是非常经典的案例。</p><p>如下述查询语句中执行器只有在全表扫描后才能知道哪些具体的不包含的记录，而无法通过索引信息过滤。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 否定查询</span><span class="token keyword">SELECT</span>     <span class="token operator">*</span> <span class="token keyword">FROM</span>     <span class="token keyword">user</span><span class="token keyword">WHERE</span>     id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于此类场景，则可以通过 <code>NOT EXISTS</code> 语法进行改造，从而转化为 <code>in</code> 查询利用索引以取得最优效率。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>     <span class="token operator">*</span><span class="token keyword">FROM</span>     <span class="token keyword">user</span> <span class="token number">a</span><span class="token keyword">WHERE</span>     <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span>        <span class="token keyword">SELECT</span>             <span class="token number">1</span>         <span class="token keyword">FROM</span>             <span class="token keyword">user</span> <span class="token number">b</span>         <span class="token keyword">WHERE</span>             <span class="token number">a</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">b</span><span class="token punctuation">.</span>id            <span class="token operator">and</span> <span class="token number">b</span><span class="token punctuation">.</span>id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在执行计划层面 <code>MySQL 8.0+</code> 对于 <code>NOT EXISTS</code> 会自动做一种称为半连接 <code>(semi-join)</code> 反半连接 <code>(anti-semi-join)</code> 的优化。</p><p>其核心在于当外层表中的一行只要在子查询结果中找到至少一条匹配行，就可以认定匹配成功，就不再继续查找。即会将子查询和外层循环改写为一种等价的 <code>JOIN</code> 结构，从而使用内表的索引避免真正的 <code>N</code> 次子查询执行。</p><p>仍以刚才改造后的 <code>NOT EXISTS</code> 为例，<code>MySQL</code> 可能改写为类似下面的逻辑：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>     <span class="token operator">*</span><span class="token keyword">FROM</span>     <span class="token keyword">user</span> <span class="token number">a</span><span class="token keyword">left</span> <span class="token keyword">join</span> <span class="token keyword">user</span> <span class="token number">b</span><span class="token keyword">on</span>     <span class="token number">a</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">b</span><span class="token punctuation">.</span>id <span class="token operator">and</span> <span class="token number">b</span><span class="token punctuation">.</span>id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">where</span>    <span class="token number">b</span><span class="token punctuation">.</span>id <span class="token operator">is</span> <span class="token boolean">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-结果排序"><a href="#2-结果排序" class="headerlink" title="2. 结果排序"></a>2. 结果排序</h4><p>在介绍确定驱动代价的时候提到了优化器同时会考虑索引可用性以及排序操作，那为什么排序会相对特殊呢？</p><p>这其中涉及一个相对隐晦的知识即 <code>order by</code> 只有针对驱动表时索引才会生效，也就是说当 <code>order by</code> 的字段来自被驱动表时，即便字段添加了索引也无法生效。</p><p>如下述查询命令中，通过 <code>straight_join</code> 指定了 <code>tb_class</code> 为驱动表，但在 <code>order by</code> 中却以被驱动表 <code>s</code> 的 <code>create_time</code> 作为排序依据，故索引也将无法生效。</p><p>此时通过执行计划查看，将会发现 <code>Extra = Using filesort</code> 表示无法使用索引，<code>MySQL</code> 需要将结果先读入临时表（如内存）进行排序，当结果集过大内存无法容纳时则需先写入文件，因此其所带来的性能损耗可想而知。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span>     <span class="token operator">*</span> <span class="token keyword">from</span> tb_class <span class="token number">c</span>straight_join tb_student s<span class="token keyword">on</span>     s<span class="token punctuation">.</span>class_id <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>id<span class="token keyword">order</span> <span class="token keyword">by</span>     s<span class="token punctuation">.</span>create_time<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，当查询涉及排序时，若查询结果集记录不大时虽性能损耗不大，但若结果集较多时，为了获得更优的查询性能应尽量保证以驱动表字段作为排序依据。</p><p>倘若在默认优化器的 <code>join</code> 下无法实现最优解则同样可利用 <code>straight_join</code> 显式指定驱动表。</p><h4 id="3-分组优化"><a href="#3-分组优化" class="headerlink" title="3. 分组优化"></a>3. 分组优化</h4><p>既然提到了 <code>order by</code> 排序，那肯定就逃不开 <code>group by</code> 分组操作。</p><p>与上述提到的排序类似，在 <code>join</code> 时 <code>group by</code> 索引生效的前提同样是索引来源表为驱动表，否则索引将失效。</p><p>同时，当混合执行 <code>order by</code> 与 <code>group by</code> 操作时，需保证二者使用字段一致且顺序也需保持一致，否则索引存在失效的情况。</p><p>如下述示例中为 <code>tb_class</code> 表字段 <code>create_time</code> 与 <code>update_time</code> 创建联合索引，虽然写法上二者都满足了最左前缀但索引仍可能失效。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span>     <span class="token operator">*</span> <span class="token keyword">from</span> tb_class <span class="token number">c</span><span class="token keyword">join</span> tb_student s<span class="token keyword">on</span>     s<span class="token punctuation">.</span>class_id <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>id<span class="token keyword">group</span> <span class="token keyword">by</span>     t<span class="token punctuation">.</span>create_time<span class="token keyword">order</span> <span class="token keyword">by</span>     t<span class="token punctuation">.</span>create_time<span class="token punctuation">,</span>    t<span class="token punctuation">.</span>update_time<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行 <code>group by</code> 分组操作时存在一个优化小技巧，即使没有显式使用 <code>order by</code> 对结果排序，<code>MySQL</code> 仍然会隐式对结果集排序。</p><p>因此，若对于返回的结果无顺序要求，可显式通过 <code>order by null</code> 关闭默认的排序行为，在执行计划中可以观察是否返回 <code>Extra = Using filesort</code>，关闭默认排序后则通常不会出现此结果。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span>    <span class="token number">c</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>    s<span class="token punctuation">.</span>name<span class="token punctuation">,</span>    <span class="token function">max</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token keyword">from</span> tb_class <span class="token number">c</span><span class="token keyword">join</span> tb_student s<span class="token keyword">on</span>     s<span class="token punctuation">.</span>class_id <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>id<span class="token keyword">group</span> <span class="token keyword">by</span>     <span class="token number">c</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>    s<span class="token punctuation">.</span>name<span class="token punctuation">,</span><span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token boolean">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、基础概念&quot;&gt;&lt;a href=&quot;#一、基础概念&quot; class=&quot;headerlink&quot; title=&quot;一、基础概念&quot;&gt;&lt;/a&gt;一、基础概念&lt;/h3&gt;&lt;h4 id=&quot;1-回表查询&quot;&gt;&lt;a href=&quot;#1-回表查询&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="数据库" scheme="https://budai.pages.dev/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://budai.pages.dev/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库 UNDO 日志详解</title>
    <link href="https://budai.pages.dev/db/undo/"/>
    <id>https://budai.pages.dev/db/undo/</id>
    <published>2025-10-08T16:00:00.000Z</published>
    <updated>2025-10-10T13:08:53.678Z</updated>
    
    <content type="html"><![CDATA[<p>在当下百花齐放的数据库中，常能看到 <code>bin log</code>、<code>redo log</code> 及 <code>undo log</code> 等名词，其各自扮演着重要角色。</p><p>而今天则让我们聚焦于 <code>undo log</code>，当开启数据事务后，数据库会将变更前的内容记录至 <code>undo</code> 文件中，当触发回滚等操作时，则可读取 <code>undo</code> 日志文件回滚至变更前原始记录，可谓是数据库事务的基石。</p><p>倘若 <code>undo log</code> 空间过慢而未及时清理，则可能导致系统服务瘫痪等风险，下面就让我们一同深入了解 <code>MySQL</code> 与 <code>Oracle</code> 中 <code>undo log</code> 其相应的机制。</p><h3 id="一、MySQL"><a href="#一、MySQL" class="headerlink" title="一、MySQL"></a>一、MySQL</h3><h4 id="1-服务配置"><a href="#1-服务配置" class="headerlink" title="1. 服务配置"></a>1. 服务配置</h4><p>正如上述所提到，<code>undo log</code> 用于处理数据库中的事务操作，可通过下述命令查询 <code>undo</code> 相关配置：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">show</span> VARIABLES <span class="token operator">like</span> <span class="token string">'%undo%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>MySQL</code> 中 <code>undo</code> 日志涉及指标如图所示：<br><img src="/album/loading.gif" data-original="/album/article/db/mysql/undo/1.png"></p><h5 id="1-innodb-undo-tablespaces"><a href="#1-innodb-undo-tablespaces" class="headerlink" title="(1) innodb_undo_tablespaces"></a>(1) innodb_undo_tablespaces</h5><p>参数为 <code>undo</code> 表空间数量，表示 <code>undo</code> 存储的文件数，如值为 <code>2</code> 数据将分为 <code>undo_001、undo_002</code> 存储。</p><p>其最大值为 <code>128</code>，在 <code>5.7</code> 中默认为 <code>0</code> 表示不独立设置 <code>tablespace</code>，即数据保存于系统表空间 <code>ibdata1</code> 中。在 <code>8.0</code> 之后默认值为 <code>2</code>，注意 <code>innodb_undo_tablespaces</code> 在服务启动之后便不可再进行调整。</p><h5 id="2-innodb-max-undo-log-size"><a href="#2-innodb-max-undo-log-size" class="headerlink" title="(2) innodb_max_undo_log_size"></a>(2) innodb_max_undo_log_size</h5><p>单个 <code>undo</code> 表空间文件的最大值，默认值为 <code>1024MB</code>。</p><h5 id="3-innodb-undo-logs"><a href="#3-innodb-undo-logs" class="headerlink" title="(3) innodb_undo_logs"></a>(3) innodb_undo_logs</h5><p>表示 <code>InnoDB</code> 可用的回滚段 <code>(Rollback Segments)</code>，存储了事务的修改前镜像，此参数在 <code>MySQL 8.0</code> 后已废弃。</p><h5 id="4-innodb-undo-log-truncate"><a href="#4-innodb-undo-log-truncate" class="headerlink" title="(4) innodb_undo_log_truncate"></a>(4) innodb_undo_log_truncate</h5><p>参数配置是否允许回收，如果为 <code>off</code> 表示不允许 <code>truncate</code> 则文件会持续增长直到磁盘满。</p><p>当值设为 <code>on</code> 开启回收时，若 <code>undo</code> 文件大小超过 <code>innodb_max_undo_log_size</code> 且表空间状态为 <code>inactive</code> 时则会重置文件至 <code>10MB</code>。</p><p>可通过下述方式手动释放空间，但需注意当前服务无进行中事务进程。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 将 undo 表空间设为非活跃</span><span class="token keyword">ALTER</span> UNDO <span class="token keyword">TABLESPACE</span> undo_001 <span class="token keyword">SET</span> INACTIVE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 截断文件</span><span class="token keyword">ALTER</span> UNDO <span class="token keyword">TABLESPACE</span> undo_001 <span class="token keyword">TRUNCATE</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 重新启用</span><span class="token keyword">ALTER</span> UNDO <span class="token keyword">TABLESPACE</span> undo_001 <span class="token keyword">SET</span> ACTIVE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-占比统计"><a href="#2-占比统计" class="headerlink" title="2. 占比统计"></a>2. 占比统计</h4><p>通过下述语句可查询当前使用中的 <code>undo</code> 槽，即一个运行时监控指标。</p><p>每个活跃事务都需要一个 <code>undo</code> 段 <code>(Segments)</code> 来存储自己的 <code>undo</code> 记录，而每个 <code>undo</code> 段会对应一个 <code>undo</code> 槽 <code>(Slot)</code>。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    NAME<span class="token punctuation">,</span>    COUNT<span class="token punctuation">,</span>    <span class="token keyword">TYPE</span><span class="token keyword">FROM</span>    information_schema<span class="token punctuation">.</span>innodb_metrics<span class="token keyword">WHERE</span>    NAME <span class="token operator">LIKE</span> <span class="token string">'trx_undo%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这边我们可以关注下述表中两个属性：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">属性</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">trx_undo_slots_used</td>        <td style="text-align: center;">当前正在使用的 slot 数量。</td>    </tr>    <tr>        <td style="text-align: center;">trx_undo_slots_cached</td>        <td style="text-align: center;">已分配但空闲的 slot。</td>    </tr></table><h3 id="二、Oracle"><a href="#二、Oracle" class="headerlink" title="二、Oracle"></a>二、Oracle</h3><h4 id="1-服务配置-1"><a href="#1-服务配置-1" class="headerlink" title="1. 服务配置"></a>1. 服务配置</h4><p>在 <code>Oracle</code> 中同样通过 <code>undo</code> 日志实现事务的管理，通过下述语句查询 <code>undo</code> 配置信息：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> PARAMETER undo<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Oracle</code> 中 <code>undo</code> 日志配置涉及下述三项指标：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">属性</td>        <th style="text-align: center;">描述</td>    </tr>    <tr>        <td style="text-align: center;">undo_tablespace</td>        <td style="text-align: center;">当前实例使用的 UNDO 表空间。</td>    </tr>    <tr>        <td style="text-align: center;">undo_management</td>        <td style="text-align: center;">一般为 AUTO，即表示自动管理。</td>    </tr>    <tr>        <td style="text-align: center;">undo_retention</td>        <td style="text-align: center;">指定事务提交后 UNDO 数据至少保留的时间（秒），默认 900 秒。</td>    </tr></table></br><p>上述查询语句需通过控制台查询，若普通查询可通过视图表实现，查询结果一致。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    name<span class="token punctuation">,</span>    <span class="token keyword">value</span><span class="token keyword">FROM</span>    v$parameter<span class="token keyword">WHERE</span>    name <span class="token operator">LIKE</span> <span class="token string">'undo%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-服务模式"><a href="#2-服务模式" class="headerlink" title="2. 服务模式"></a>2. 服务模式</h4><p><code>Oracle</code> 中的 <code>undo</code> 日志文件同样涉及清除操作，通过不同的保证模式实现控制。</p><p>通过下述语句查询不同命名空间的保证模式：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    tablespace_name<span class="token punctuation">,</span>    retention<span class="token keyword">FROM</span>    dba_tablespaces<span class="token keyword">WHERE</span>    tablespace_name <span class="token operator">LIKE</span> <span class="token string">'UNDO%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-NOGUARANTEE"><a href="#1-NOGUARANTEE" class="headerlink" title="(1) NOGUARANTEE"></a>(1) NOGUARANTEE</h5><p>默认值，当空间不足时即使没到 <code>undo_retention</code> 时间，也会覆盖旧的 <code>undo</code> 数据。</p><h5 id="2-GUARANTEE"><a href="#2-GUARANTEE" class="headerlink" title="(2) GUARANTEE"></a>(2) GUARANTEE</h5><p>严格保证 <code>undo_retention</code>，即在保留时间内 <code>undo</code> 数据不会被覆盖，可能导致 <code>DML</code> 报错。</p><p>可通过下述命令修改 <code>undo</code> 日志保证模式：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> UNDO <span class="token keyword">TABLESPACE</span> undotbs1 RETENTION GUARANTEE<span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> UNDO <span class="token keyword">TABLESPACE</span> undotbs1 RETENTION NOGUARANTEE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-文件信息"><a href="#3-文件信息" class="headerlink" title="3. 文件信息"></a>3. 文件信息</h4><p>通过下述语句则可查询当前 <code>undo</code> 日志每个命名空间的文件使用情况。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    tablespace_name<span class="token punctuation">,</span>    file_name<span class="token punctuation">,</span>    bytes <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token keyword">AS</span> size_mb<span class="token punctuation">,</span>    autoextensible<span class="token punctuation">,</span>    maxbytes <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token keyword">AS</span> max_size_mb<span class="token keyword">FROM</span>    dba_data_files<span class="token keyword">WHERE</span>    tablespace_name <span class="token operator">=</span> <span class="token string">'UNDOTBS1'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-进程状态"><a href="#4-进程状态" class="headerlink" title="4. 进程状态"></a>4. 进程状态</h5><p>同样的，以 <code>undo_retention</code> 过期时间为依据，每个 <code>undo</code> 日志命名空间下的进程也存在状态区分。</p><p>通过下述语句便可统计查询各命名空间下不同状态文件的占用情况。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    tablespace_name<span class="token punctuation">,</span>    <span class="token keyword">status</span><span class="token punctuation">,</span>    <span class="token function">SUM</span> <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token string">"Bytes(M)"</span><span class="token keyword">FROM</span>    dba_undo_extents<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>    tablespace_name<span class="token punctuation">,</span>    <span class="token keyword">status</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-status-ACTIVE"><a href="#1-status-ACTIVE" class="headerlink" title="(1) status = ACTIVE"></a>(1) status = ACTIVE</h5><p>表示当前有事务正在使用该 <code>extent</code>，不能覆盖。</p><h5 id="2-status-UNEXPIRED"><a href="#2-status-UNEXPIRED" class="headerlink" title="(2) status = UNEXPIRED"></a>(2) status = UNEXPIRED</h5><p>表示其已经没有事务在使用中，但仍在 <code>undo_retention</code> 保留期内，理论上不会覆盖除非空间不足（若处于 <code>NOGUARANTEE</code> 模式）。</p><h5 id="3-status-EXPIRED"><a href="#3-status-EXPIRED" class="headerlink" title="(3) status = EXPIRED"></a>(3) status = EXPIRED</h5><p>表示已经过了保留期，可以被新的事务覆盖使用；<br></br></p><p>下述语句则不区分 <code>status</code> 状态，统计当前 <code>undo</code> 使用信息:</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    <span class="token number">a</span><span class="token punctuation">.</span>tablespace_name<span class="token punctuation">,</span>    <span class="token function">ROUND</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">.</span>bytes <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> total_mb<span class="token punctuation">,</span>    <span class="token function">ROUND</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">.</span>bytes <span class="token operator">-</span> <span class="token number">b</span><span class="token punctuation">.</span>bytes_used<span class="token punctuation">)</span><span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> used_mb<span class="token punctuation">,</span>    <span class="token function">ROUND</span><span class="token punctuation">(</span><span class="token number">b</span><span class="token punctuation">.</span>bytes_used <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> free_mb<span class="token punctuation">,</span>    <span class="token function">ROUND</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">.</span>bytes <span class="token operator">-</span> <span class="token number">b</span><span class="token punctuation">.</span>bytes_used<span class="token punctuation">)</span><span class="token operator">/</span> <span class="token number">a</span><span class="token punctuation">.</span>bytes<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> used_percent<span class="token keyword">FROM</span>    <span class="token punctuation">(</span>        <span class="token keyword">SELECT</span>            tablespace_name<span class="token punctuation">,</span>            <span class="token function">SUM</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span> bytes        <span class="token keyword">FROM</span>            dba_data_files        <span class="token keyword">WHERE</span>            tablespace_name <span class="token operator">LIKE</span> <span class="token string">'UNDO%'</span>        <span class="token keyword">GROUP</span> <span class="token keyword">BY</span>            tablespace_name    <span class="token punctuation">)</span> <span class="token number">a</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span>        <span class="token keyword">SELECT</span>            tablespace_name<span class="token punctuation">,</span>            <span class="token function">SUM</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span> bytes_used        <span class="token keyword">FROM</span>            dba_free_space        <span class="token keyword">WHERE</span>            tablespace_name <span class="token operator">LIKE</span> <span class="token string">'UNDO%'</span>        <span class="token keyword">GROUP</span> <span class="token keyword">BY</span>            tablespace_name    <span class="token punctuation">)</span> <span class="token number">b</span><span class="token keyword">WHERE</span>    <span class="token number">a</span><span class="token punctuation">.</span>tablespace_name <span class="token operator">=</span> <span class="token number">b</span><span class="token punctuation">.</span>tablespace_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在当下百花齐放的数据库中，常能看到 &lt;code&gt;bin log&lt;/code&gt;、&lt;code&gt;redo log&lt;/code&gt; 及 &lt;code&gt;undo log&lt;/code&gt; 等名词，其各自扮演着重要角色。&lt;/p&gt;
&lt;p&gt;而今天则让我们聚焦于 &lt;code&gt;undo log&lt;/co</summary>
      
    
    
    
    <category term="数据库" scheme="https://budai.pages.dev/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Oracle" scheme="https://budai.pages.dev/tags/Oracle/"/>
    
    <category term="MySQL" scheme="https://budai.pages.dev/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis Plus批处理优化</title>
    <link href="https://budai.pages.dev/java/spring/mybatis/optimization/"/>
    <id>https://budai.pages.dev/java/spring/mybatis/optimization/</id>
    <published>2025-10-04T16:00:00.000Z</published>
    <updated>2025-10-08T13:43:33.137Z</updated>
    
    <content type="html"><![CDATA[<p><code>MyBatis Plus</code> 作为 <code>MyBatis</code> 的增强版为单表提供了丰富的读写操作，可极大降低代码工程量。</p><p>而今天，就让我们一并深入了解如何在 <code>MyBatis Plus</code> 中最大化批量操作性能。</p><p>下面就以具体的工程示例让介绍具体的批量操作调优。</p><h3 id="一、项目示例"><a href="#一、项目示例" class="headerlink" title="一、项目示例"></a>一、项目示例</h3><h4 id="1-数据构建"><a href="#1-数据构建" class="headerlink" title="1. 数据构建"></a>1. 数据构建</h4><p>在具体的代码开始前首先准备测试表，建表脚本如下：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> unsigned <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>age<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>email<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>address<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>create_by<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成建表之后，按照上述数据结构模拟生成构建测试数据。</p><p>逻辑并不复杂这里不展开描述，代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>User<span class="token operator">>></span> <span class="token function">mockData</span><span class="token punctuation">(</span>Integer size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 构造测试数据</span>    LocalDateTime now <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"name-"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setEmail</span><span class="token punctuation">(</span><span class="token string">"email-"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"address-"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setCreateBy</span><span class="token punctuation">(</span>0L<span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setCreateTime</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>        users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 按 500 拆分多批次</span>    <span class="token keyword">return</span> <span class="token function">partition</span><span class="token punctuation">(</span>users<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-批量保存"><a href="#2-批量保存" class="headerlink" title="2. 批量保存"></a>2. 批量保存</h4><p>那么以批量保存为例，一并来看如何在 <code>Mybatis Plus</code> 中如何实现数据插入。</p><p>这里略去其余无关配置项，直入主题可以看到 <code>MP</code> 在 <code>service</code> 父级封装类中提供了 <code>saveBatch()</code> 批量保存方法。</p><p>同时，在操作批量插入时为了更优的性能常分批进行保存提交，至于其缘由后续再进行阐述。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> UserService userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"insert1"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert1</span><span class="token punctuation">(</span>Integer size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>User<span class="token operator">>></span> lists <span class="token operator">=</span> <span class="token function">mockData</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> l <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>List<span class="token operator">&lt;</span>User<span class="token operator">></span> batch <span class="token operator">:</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>            userService<span class="token punctuation">.</span><span class="token function">saveBatch</span><span class="token punctuation">(</span>batch<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"insert1 time: {} ms"</span><span class="token punctuation">,</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-原生插入"><a href="#3-原生插入" class="headerlink" title="3. 原生插入"></a>3. 原生插入</h4><p>同理，利用 <code>SQL</code> 中默认的 <code>insert values</code> 语法，则可在原生的 <code>MyBatis</code> 中利用 <code>foreach</code> 语法在 <code>xml</code> 中手动编写语句从而实现批量插入。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertBatch<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">useGeneratedKeys</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    insert into user(name, age, email, address, create_by, create_time)    values    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>entities<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>entity<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        (#{entity.name}, #{entity.age}, #{entity.email}, #{entity.address}, #{entity.createBy}, #{entity.createTime})    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于上述原生 <code>SQL</code> 语法，其对应的批量数据保存示例如下，同样采取了分批提交的方式。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> UserDao userDao<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"insert2"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert1</span><span class="token punctuation">(</span>Integer size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>User<span class="token operator">>></span> lists <span class="token operator">=</span> <span class="token function">mockData</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> l <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>List<span class="token operator">&lt;</span>User<span class="token operator">></span> batch <span class="token operator">:</span> lists<span class="token punctuation">)</span> <span class="token punctuation">{</span>            userDao<span class="token punctuation">.</span><span class="token function">insertBatch</span><span class="token punctuation">(</span>batch<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"insert2 time: {} ms"</span><span class="token punctuation">,</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-性能分析"><a href="#4-性能分析" class="headerlink" title="4. 性能分析"></a>4. 性能分析</h4><p>基于上述的两个示例，以 <code>1w</code> 条数据为例分别执行两个代码块，日志统计如下所示。</p><p>从日志结果可以看到 <code>MP</code> 中的批量操作相较于原生的批量操作更为耗时。</p><pre class="line-numbers language-txt"><code class="language-txt">com.example.controller.UserController    : insert1 time: 3135 mscom.example.controller.UserController    : insert2 time: 607 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>继续扩大测试集，以 <code>10w</code> 条记录插入为例，从日志可以看到 <code>MP</code> 中的批量耗时仍远超于原生操作。</p><pre class="line-numbers language-txt"><code class="language-txt">com.example.controller.UserController    : insert1 time: 22871 mscom.example.controller.UserController    : insert2 time: 5927 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="二、机制剖析"><a href="#二、机制剖析" class="headerlink" title="二、机制剖析"></a>二、机制剖析</h3><h4 id="1-源码解读"><a href="#1-源码解读" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h4><p>那么，造成这一现象的原因又是什么呢？</p><p>查看 <code>MP</code> 中的 <code>saveBatch()</code> 实现代码可以看到，其批量操作的核心在于开启长会话 <code>sqlSession()</code>，在会话中遍历数据执行插入等数据操作，当达到批次大小时通过 <code>flushStatements()</code> 将本批次的数据提交至数据库。</p><p>基于此模式下，与数据库的网络请求交互则可大大下降。以 <code>1w</code> 条数据为例且批次大小为 <code>1k</code> 为例，与数据库的网络 <code>IO</code> 则从 <code>1w</code> 次下降至 <code>10</code> 次，所带来的提供不言而喻。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">boolean</span> <span class="token function">executeBatch</span><span class="token punctuation">(</span>SqlSessionFactory sqlSessionFactory<span class="token punctuation">,</span> Log log<span class="token punctuation">,</span> Collection<span class="token operator">&lt;</span>E<span class="token operator">></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> batchSize<span class="token punctuation">,</span> BiConsumer<span class="token operator">&lt;</span>SqlSession<span class="token punctuation">,</span> E<span class="token operator">></span> consumer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Assert<span class="token punctuation">.</span><span class="token function">isFalse</span><span class="token punctuation">(</span>batchSize <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"batchSize must not be less than one"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">!</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">executeBatch</span><span class="token punctuation">(</span>sqlSessionFactory<span class="token punctuation">,</span> log<span class="token punctuation">,</span> <span class="token punctuation">(</span>sqlSession<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idxLimit <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>batchSize<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Iterator var7 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> var7<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            E element <span class="token operator">=</span> var7<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            consumer<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> idxLimit<span class="token punctuation">)</span> <span class="token punctuation">{</span>                sqlSession<span class="token punctuation">.</span><span class="token function">flushStatements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                idxLimit <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>idxLimit <span class="token operator">+</span> batchSize<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到这你也许有个疑问，既然降低了网络开销那相较于原生 <code>SQL</code> 为什么仍无法取得相同的性能表现。</p><p>这其中的差异之处则是由于数据库自身的实现所带来的，虽然在 <code>MP</code> 中虽然通过长会话节省了网络开销，但数据库层面接受到的仍然是独立的 <code>n</code> 条插入语句，仍需要逐条执行。</p><p>而在原生的 <code>SQL</code> 中通过拼接后数据库所接收到的语句数则为 <code>记录数/批量数</code>。因此，随着数据的递增二者的差异将更为明显，故在大批量的数据操作中更推荐原生的 <code>SQL</code> 方式。</p><h4 id="2-批量更新"><a href="#2-批量更新" class="headerlink" title="2. 批量更新"></a>2. 批量更新</h4><p>了解二者背后的机制后，我们知道在大批量数据下 MP 自带的批量并非最优解。</p><p>而在批量插入中则可利用 <code>insert values</code> 实现，批量删除同样可以通过预处理后 <code>in</code> 条件实现。那么，针对批量更新则应当如何处理呢？</p><p>虽然在 <code>MySQL</code> 等数据库中针对更新没有类似的 <code>insert values</code> 的语法，但提供了取巧的方式支持 <code>SQL</code> 合并提供，通过在连接信息中添加 <code>allowMultiQueries=true</code> 参数允许多语句提交。</p><pre class="line-numbers language-yaml"><code class="language-yaml">jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>3306/database<span class="token punctuation">?</span>allowMultiQueries=true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么，即可在 <code>xml</code> 中通过 <code>foreach</code> 标签拼接合并更新语句从而实现性能最大化。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>update</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>updateBatch<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.util.List<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        update user        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item.name !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>                name = #{item.name},            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item.age !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>                age = #{item.age},            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item.email !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>                email = #{item.email},            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item.address !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>                address = #{item.address},            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item.createBy !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>                create_by = #{item.createBy},            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item.createTime !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>                create_time = #{item.createTime}            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">></span></span>        where id = #{item.id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>update</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;MyBatis Plus&lt;/code&gt; 作为 &lt;code&gt;MyBatis&lt;/code&gt; 的增强版为单表提供了丰富的读写操作，可极大降低代码工程量。&lt;/p&gt;
&lt;p&gt;而今天，就让我们一并深入了解如何在 &lt;code&gt;MyBatis Plus&lt;/code&gt; 中最大化批量</summary>
      
    
    
    
    <category term="Java Web" scheme="https://budai.pages.dev/categories/Java-Web/"/>
    
    
    <category term="Spring Boot" scheme="https://budai.pages.dev/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>MethodHandle 反射详解</title>
    <link href="https://budai.pages.dev/java/advance/methodhandle/"/>
    <id>https://budai.pages.dev/java/advance/methodhandle/</id>
    <published>2025-08-15T16:00:00.000Z</published>
    <updated>2025-08-25T14:06:45.763Z</updated>
    
    <content type="html"><![CDATA[<p>反射作为 <code>Java</code> 中的万能百宝箱，不论在系统设计还是工具开发中都能频繁看到其身影。</p><p>但我们也都知道由于其运行动态编译的特点导致 <code>JIT</code> 无法介入，相较于方法的调用在性能上存在损耗。</p><p>那难道鱼和熊掌不可兼得吗，<code>JDK</code> 也意识到了这一点，因此在 <code>JDK 7</code> 中引入 <code>MethodHandles</code> 全新的反射框架，下面就让我们一睹芳容。</p><h3 id="一、反射进阶"><a href="#一、反射进阶" class="headerlink" title="一、反射进阶"></a>一、反射进阶</h3><h4 id="1-实例声明"><a href="#1-实例声明" class="headerlink" title="1. 实例声明"></a>1. 实例声明</h4><p><code>MethodHandles</code> 的声明十分简单，通过静态方法实例化即可，方式如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    MethodHandles<span class="token punctuation">.</span>Lookup lookup <span class="token operator">=</span> MethodHandles<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但需注意一点，默认 <code>lookup()</code> 声明的实例仅允许访问 public 属性无法访问私有属性。在传统的反射中可通过 <code>setAccessible(true)</code> 实现越权但 <code>MethodHandles</code> 中并不支持。</p><p>若想要实现私有属性的访问，在声明实例时需稍微变通一下。</p><p>查看 <code>Lookup</code> 的源码可以看见其提供私有的构造器可指定 <code>allowedModes</code> 即访问方式，利用其我们便可绕过限制实现越权。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Lookup</span> <span class="token punctuation">{</span>    <span class="token function">Lookup</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> lookupClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>lookupClass<span class="token punctuation">,</span> ALL_MODES<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">checkUnprivilegedlookupClass</span><span class="token punctuation">(</span>lookupClass<span class="token punctuation">,</span> ALL_MODES<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">Lookup</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> lookupClass<span class="token punctuation">,</span> <span class="token keyword">int</span> allowedModes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lookupClass <span class="token operator">=</span> lookupClass<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>allowedModes <span class="token operator">=</span> allowedModes<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于此类 <code>private</code> 构造器，最经典的方式即利用传统反射实现初始化。</p><p>详细的代码实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Constructor<span class="token operator">&lt;</span>MethodHandles<span class="token punctuation">.</span>Lookup<span class="token operator">></span> ctor <span class="token operator">=</span>            MethodHandles<span class="token punctuation">.</span>Lookup<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>Class<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MethodHandles<span class="token punctuation">.</span>Lookup lookup <span class="token operator">=</span>             ctor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> MethodHandles<span class="token punctuation">.</span>Lookup<span class="token punctuation">.</span>PRIVATE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在 <code>JDK 9</code> 之后引入了模块化管理，因此 <code>JDK 9</code> 之后也默认提供 <code>privateLookupIn()</code> 方式可实现私有访问，无需再通过反射处理。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    MethodHandles<span class="token punctuation">.</span>Lookup lookup <span class="token operator">=</span>             MethodHandles<span class="token punctuation">.</span><span class="token function">privateLookupIn</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> MethodHandles<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、字段反射"><a href="#二、字段反射" class="headerlink" title="二、字段反射"></a>二、字段反射</h3><p>在完成实例化之后，让我们先看看如何通过 <code>MethodHandles</code> 实现字段属性的反射操作。</p><h4 id="1-属性读取"><a href="#1-属性读取" class="headerlink" title="1. 属性读取"></a>1. 属性读取</h4><p>对于对象的字段访问，最基本的操作即读写与写入，先以数据读取为例。</p><p>在 <code>MethodHandles</code> 中字段的读取可谓相当简单，提供了 <code>findGetter()</code> 与 <code>findStaticGetter()</code> 分别用于获取普通与静态字段实例，即对应传统反射中的 <code>Field</code> 变量。</p><p>而对于获取的 <code>MethodHandle</code> 实例变量，通过 <code>invoke()</code> 方法便可读取字段内容，操作示例如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String name <span class="token operator">=</span> <span class="token string">"Alex"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>    Foo foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MethodHandles<span class="token punctuation">.</span>Lookup lookup <span class="token operator">=</span> MethodHandles            <span class="token punctuation">.</span><span class="token function">privateLookupIn</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> MethodHandles<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MethodHandle getter <span class="token operator">=</span> lookup<span class="token punctuation">.</span><span class="token function">findGetter</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"id"</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>getter<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MethodHandle staticGetter <span class="token operator">=</span> lookup<span class="token punctuation">.</span><span class="token function">findStaticGetter</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>staticGetter<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如之前所提到的，在 <code>MethodHandles</code> 中无需 <code>setAccessible(true)</code> 设置访问权限，而是在声明实例直接定义，如上述代码示例中通过 <code>privateLookupIn()</code> 即可访问公有及私有属性实例。</p><h4 id="2-属性赋值"><a href="#2-属性赋值" class="headerlink" title="2. 属性赋值"></a>2. 属性赋值</h4><p>与属性读取相对应，对于字段的赋值同样提供了 <code>findSetter()</code> 与 <code>findStaticSetter()</code> 方法。</p><p>在使用上并无差异故不再复述，相应的使用示例如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>    Foo foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MethodHandles<span class="token punctuation">.</span>Lookup lookup <span class="token operator">=</span> MethodHandles            <span class="token punctuation">.</span><span class="token function">privateLookupIn</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> MethodHandles<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MethodHandle setter <span class="token operator">=</span> lookup<span class="token punctuation">.</span><span class="token function">findSetter</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"id"</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    setter<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MethodHandle staticSetter <span class="token operator">=</span> lookup<span class="token punctuation">.</span><span class="token function">findStaticSetter</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    staticSetter<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、方法反射"><a href="#三、方法反射" class="headerlink" title="三、方法反射"></a>三、方法反射</h3><p>下面同样让我们了解下如何通过 <code>MethodHandles</code> 实现方法的反射调用。</p><h4 id="1-方法描述"><a href="#1-方法描述" class="headerlink" title="1. 方法描述"></a>1. 方法描述</h4><p>在开始前让我们先声明一个简单的测试类方法如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们都知道在传统的反射中，通过类对象的 <code>getMethod()</code> 方法便可获取方法属性。</p><pre class="line-numbers language-java"><code class="language-java">Method method <span class="token operator">=</span> Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"sayHi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而在 <code>MethodHandles</code> 中方法与之前字段反射中的类似，以 <code>MethodType</code> 进行描述。</p><p>通过查看 <code>MethodType</code> 其初始化方法可以看到，由返回值和方法入参构建了一个方法的描述体。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> MethodType <span class="token function">methodType</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> rtype<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> MethodType <span class="token function">methodType</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> rtype<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> ptype0<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ptypes<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在构建 <code>MethodType</code> 方法描述之后，便可通过 <code>findVirtual()</code> 方法获取方法实现，通过 <code>MethodType</code> 实现方法的精确定位。</p><pre class="line-numbers language-java"><code class="language-java">MethodHandle mh <span class="token operator">=</span> lookup<span class="token punctuation">.</span><span class="token function">findVirtual</span><span class="token punctuation">(</span>        Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        <span class="token string">"sayHi"</span><span class="token punctuation">,</span>        MethodType<span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与之前的字段反射类似，<code>findVirtual()</code> 实现了普通方法的获取，而 <code>findStatic()</code> 针对于静态方法而言，在具体的使用上并无太大差异这里不再举例介绍。</p><h4 id="2-链路调用"><a href="#2-链路调用" class="headerlink" title="2. 链路调用"></a>2. 链路调用</h4><p>获取方法示例之后调用方式十分简单，通过 <code>invoke(obj)</code> 调用即可，针对静态方法则通过 <code>invoke()</code> 执行。</p><p>相对应的代码示例如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span>Foo<span class="token operator">></span> clazz <span class="token operator">=</span> Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    MethodHandles<span class="token punctuation">.</span>Lookup lookup <span class="token operator">=</span> MethodHandles            <span class="token punctuation">.</span><span class="token function">privateLookupIn</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> MethodHandles<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MethodHandle constructor <span class="token operator">=</span> lookup<span class="token punctuation">.</span><span class="token function">findConstructor</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> MethodType<span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object foo <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MethodHandle mh <span class="token operator">=</span> lookup<span class="token punctuation">.</span><span class="token function">findVirtual</span><span class="token punctuation">(</span>            clazz<span class="token punctuation">,</span>            <span class="token string">"one"</span><span class="token punctuation">,</span>            MethodType<span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    mh<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四、性能差异"><a href="#四、性能差异" class="headerlink" title="四、性能差异"></a>四、性能差异</h3><h4 id="1-传统反射"><a href="#1-传统反射" class="headerlink" title="1. 传统反射"></a>1. 传统反射</h4><p>看到这你也许有个疑问，同样都是 <code>invoke()</code> 执行调用，那差异到底在哪？</p><p>让我们先看下传统的反射执行链路，<code>JDK</code> 里反射的实现分为两类：本地代码解释调用 <code>(Native Reflection / Inflated)</code> 和字节码生成的快速调用 <code>(Generated MethodAccessor)</code></p><h5 id="1-本地代码调用"><a href="#1-本地代码调用" class="headerlink" title="(1) 本地代码调用"></a>(1) 本地代码调用</h5><p>本地代码调用即通过 <code>JNI</code> 调用 <code>HotSpot</code> 内部的 <code>MethodAccessor</code>。</p><p>优点是不需要生成新类启动速度快，但每次反射调用都会经过很多安全检查，当调用次数达到一定数量时性能相对较低。</p><h5 id="2-字节码生成调用"><a href="#2-字节码生成调用" class="headerlink" title="(2) 字节码生成调用"></a>(2) 字节码生成调用</h5><p>字节码生成调用则为动态生成一个字节码类 <code>(MethodAccessorImpl 子类)</code>，直接调用目标方法。</p><p>优点即性能接近普通方法调用，但缺点就是生成类有开销，如果方法只调用几次反而得不偿失。</p><p>因此在传统的反射中当 <code>Method / Constructor / Field</code> 反射调用中，前 15 次执行方式为本地代码调用。当的次数超过 <code>15</code> 次后，<code>JDK</code> 就会膨胀执行链路将转为字节码生成调用。</p><p>其中 <code>inflationThreshold</code> 为代码中静态 <code>final</code> 参数不可调整。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReflectionFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> inflationThreshold <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">NativeMethodAccessorImpl</span> <span class="token keyword">extends</span> <span class="token class-name">MethodAccessorImpl</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> Object <span class="token function">invoke0</span><span class="token punctuation">(</span>Method m<span class="token punctuation">,</span> Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-反射优化"><a href="#2-反射优化" class="headerlink" title="2. 反射优化"></a>2. 反射优化</h4><p>查看 <code>MethodHandle</code> 类中的定义内容，可以看到 <code>invoke()</code> 方法同样为 <code>native</code> 方法，不同之处其多了 <code>@IntrinsicCandidate</code> 与 <code>@PolymorphicSignature</code> 注解。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MethodHandle</span> <span class="token keyword">implements</span> <span class="token class-name">Constable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@IntrinsicCandidate</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token annotation punctuation">@PolymorphicSignature</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>MethodHandle</code> 性能更优的关键也同样在此，下面分别介绍两个注解的作用。</p><h5 id="1-IntrinsicCandidate"><a href="#1-IntrinsicCandidate" class="headerlink" title="(1) @IntrinsicCandidate"></a>(1) @IntrinsicCandidate</h5><p><code>@IntrinsicCandidate</code> 标记某个方法是 <code>JVM intrinsic</code> 内建方法。</p><p>内建方法即在 <code>JDK</code> 代码中有 <code>Java</code> 实现，但 <code>JVM</code> 在执行时会替换成高效的 <code>CPU</code> 指令或专门的优化实现。</p><p>通过 <code>@IntrinsicCandidate</code> 标记告诉 <code>HotSpot</code> 该方法有可能被 <code>intrinsic</code> 优化，并且可以在 <code>JIT</code> 编译中进行替换。它不保证一定优化成功，也不影响方法的正常调用，完全是 <code>JVM</code> 和 <code>JDK</code> 之间的内部约定。</p><h5 id="2-PolymorphicSignature"><a href="#2-PolymorphicSignature" class="headerlink" title="(2) @PolymorphicSignature"></a>(2) @PolymorphicSignature</h5><p><code>@PolymorphicSignature</code> 标识一个方法是多态签名方法 <code>(polymorphic signature method)</code>。</p><p>正常情况下，<code>Java</code> 方法签名是编译期就固定的（参数类型、返回类型完全确定）。但 <code>MethodHandle</code> 是 <code>Java 7</code> 引入的动态调用机制，需要在运行时根据不同类型的参数调用不同的方法实现。</p><p>于是，<code>JVM</code> 允许某些特殊方法在字节码层看起来是签名不固定的，它们会在运行时再解析具体的签名。</p><p>通过上面的分别可以看到，基于注解标注 <code>JVM</code> 在 <code>native</code> 实现中进行了二次优化从而实现 <code>JIT</code> 接入与更优性能表现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;反射作为 &lt;code&gt;Java&lt;/code&gt; 中的万能百宝箱，不论在系统设计还是工具开发中都能频繁看到其身影。&lt;/p&gt;
&lt;p&gt;但我们也都知道由于其运行动态编译的特点导致 &lt;code&gt;JIT&lt;/code&gt; 无法介入，相较于方法的调用在性能上存在损耗。&lt;/p&gt;
&lt;p&gt;那难道鱼和</summary>
      
    
    
    
    <category term="JAVA进阶" scheme="https://budai.pages.dev/categories/JAVA%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="JAVA" scheme="https://budai.pages.dev/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Spring 事务回调管理</title>
    <link href="https://budai.pages.dev/java/spring/transaction/callback/"/>
    <id>https://budai.pages.dev/java/spring/transaction/callback/</id>
    <published>2025-08-10T16:00:00.000Z</published>
    <updated>2025-10-13T11:52:27.144Z</updated>
    
    <content type="html"><![CDATA[<p>在业务流程中，事务常扮演着重要作用，为数据提供了原子性保证。</p><p>而对于事务管理，秉承着最小化的逻辑，针对非数据库操作且耗时动作，在设计上通常需要独立于事务之外，避免资源竞争造成性能损耗。</p><p>在此类业务逻辑中，当然你可以 <code>DataSourceTransactionManager</code> 手动开启事务并提交。但显然如何一来也将提高代码复杂度，那在基于 <code>@Transactiona</code> 注解的前提下，如何实现事务的回调处理呢？</p><p>下面就让我们一同探究如何在 <code>Spring Boot</code> 中优化的实现事务回调。</p><h4 id="1-回调事件"><a href="#1-回调事件" class="headerlink" title="1. 回调事件"></a>1. 回调事件</h4><p>让我们直接开门见山，在 <code>Spring Boot</code> 中提供 <code>TransactionSynchronizationManager</code> 可实现对事务的回调注册。</p><p>在回调事件注册中，会涉及如下两个方法，具体描述参考表格。</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">方法</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">isActualTransactionActive()</td>        <td style="text-align: center;">是否当前线程是否处于事务中。</td>    </tr>    <tr>        <td style="text-align: center;">registerSynchronization()</td>        <td style="text-align: center;">事务同步注册接口。</td>    </tr></table></br><p>基于上述描述，我们便可判断当前线程是否处于事务中，若是则注册回调逻辑。</p><p>由此，事务回调的基本实现思路并已确定，对应下述实现代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">callback</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断事务处于事务中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>TransactionSynchronizationManager<span class="token punctuation">.</span><span class="token function">isActualTransactionActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 若是，则注册回调事件</span>        TransactionSynchronizationManager<span class="token punctuation">.</span><span class="token function">registerSynchronization</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CallBackTask</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-同步注册"><a href="#2-同步注册" class="headerlink" title="2. 同步注册"></a>2. 同步注册</h4><p>在 <code>registerSynchronization()</code> 注册回调接口时，其要求输入 <code>TransactionSynchronization</code> 接口实例。</p><p>接口中针对事务的不同阶段提供了不同的钩子，同时可以获取事务处理状态，所涉及的方法如下：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">方法</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">beforeCommit()</td>        <td style="text-align: center;">事务提交之前事件。</td>    </tr>    <tr>        <td style="text-align: center;">beforeCompletion()</td>        <td style="text-align: center;">事务完成之前事件。</td>    </tr>    <tr>        <td style="text-align: center;">afterCommit()</td>        <td style="text-align: center;">事务提交之后事件。</td>    </tr>    <tr>        <td style="text-align: center;">afterCompletion()</td>        <td style="text-align: center;">事务完成之后事件。</td>    </tr></table></br><p>针对表中所提到的不同事务阶段，为了更直观的展示让我们以图示进行说明。</p><p>其中 <code>doSomthing()</code> 为具体的业务逻辑，图示流程即从开启事务后最终提交并完成一个完整的事务周期。<br><img src="/album/loading.gif" data-original="/album/article/java/spring/transaction/3.png"></p><p>接着之前的 <code>registerSynchronization()</code> 逻辑，让我们编写具体的回调处理逻辑。</p><p>新增 <code>CallBackTask</code> 并实现 <code>TransactionSynchronization</code> 接口，因此需处理事务完成后的回调逻辑，故此实现 <code>afterCompletion()</code> 钩子。</p><p>而在 <code>afterCompletion()</code> 中可以获取当前事务的完成状态，分别包含下述三类：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">方法</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">STATUS_UNKNOWN</td>        <td style="text-align: center;">未知状态。</td>    </tr>    <tr>        <td style="text-align: center;">STATUS_COMMITTED</td>        <td style="text-align: center;">事务提交成功。</td>    </tr>    <tr>        <td style="text-align: center;">STATUS_ROLLED_BACK</td>        <td style="text-align: center;">事务失败回滚。</td>    </tr></table></br><p>基于上述内容，我们便可在指定事务状态下发起不同的回调逻辑。</p><p>以下述代码为例，传入 <code>Runnable</code> 线程回调逻辑，并在状态为 <code>STATUS_COMMITTED</code> 即事务成功提交后出发回调。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallBackTask</span> <span class="token keyword">implements</span> <span class="token class-name">TransactionSynchronization</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Runnable runnable<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CallBackTask</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>runnable <span class="token operator">=</span> runnable<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> TransactionSynchronization<span class="token punctuation">.</span>STATUS_UNKNOWN<span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Unknown"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> TransactionSynchronization<span class="token punctuation">.</span>STATUS_COMMITTED<span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Transaction is committed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 事务提交成功，执行回调</span>                runnable<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> TransactionSynchronization<span class="token punctuation">.</span>STATUS_ROLLED_BACK<span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Transaction is rolled back"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h4><p>让我们先假定业务场景，假如功能需要保存某业务数据，在保存成功后将数据同步至下游系统，而数据同步的总体耗时约 <code>30s</code> 左右。</p><p>基于此场景，最原始的方式即通过 <code>@Transactional</code> 注解针对整个方法开始事务。但如此设计存在一个问题，推送数据耗时导致事务迟迟无法提交，不仅降低服务性能且长时间事务挂起存在数据一致性问题。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">directInsert</span><span class="token punctuation">(</span>SysUser user<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 数据入库</span>    sysUserDao<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 模拟耗时</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于涉及事务处理的逻辑而言，永远要保持一个原则：<strong>最小化</strong>。</p><p>事务并不是并发的有效解决方法，针对同一条数据而言更优解往往是基于锁与事务的结合。通过锁保证同一记录的冲突，而事务则实现了不同数据间的隔离。</p><p>通过锁与事务的结合，各自实现最小化管理从而取得最佳性能。<br><img src="/album/loading.gif" data-original="/album/article/java/spring/transaction/4.png"></p><h4 id="4-集成示例"><a href="#4-集成示例" class="headerlink" title="4. 集成示例"></a>4. 集成示例</h4><p>因此，对于上述的代码而言可以轻易改造为下述方式，即针对数据库操作部分单独抽象为事务操作，既实现了事务又可取得相对不错的性能。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">manualCallback</span><span class="token punctuation">(</span>SysUser user<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 数据入库, insert() 需获取代理对象操作，此处略去</span>    <span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 模拟耗时</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>SysUser user<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sysUserDao<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在第二个示例中，虽然实现了最终预期，但从代码上可以看出极易操作事务失效的情况，需通过 <code>AopContext</code> 创建代理对象处理。</p><p>再次改造上述的示例，同样是在一个方法内基于 <code>@Transactional</code> 开启事务。但通过之前定义的 <code>TransactionManager</code> 传入事务回调，当事务完成时将触发回调内容，实现与上述同样效果但代码更为精简。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callbackInsert</span><span class="token punctuation">(</span>SysUser user<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 数据入库</span>    sysUserDao<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 事务回调</span>    TransactionManager<span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 模拟耗时</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在业务流程中，事务常扮演着重要作用，为数据提供了原子性保证。&lt;/p&gt;
&lt;p&gt;而对于事务管理，秉承着最小化的逻辑，针对非数据库操作且耗时动作，在设计上通常需要独立于事务之外，避免资源竞争造成性能损耗。&lt;/p&gt;
&lt;p&gt;在此类业务逻辑中，当然你可以 &lt;code&gt;DataSourc</summary>
      
    
    
    
    <category term="Spring框架" scheme="https://budai.pages.dev/categories/Spring%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring Boot" scheme="https://budai.pages.dev/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 代理实践应用</title>
    <link href="https://budai.pages.dev/linux/nginx/practice/"/>
    <id>https://budai.pages.dev/linux/nginx/practice/</id>
    <published>2025-08-07T16:00:00.000Z</published>
    <updated>2025-11-08T07:50:59.289Z</updated>
    
    <content type="html"><![CDATA[<p><code>Nginx</code> 作为网络代理领域的绝对王者，在系统中的方方面面都能看到它的身影。</p><p>在之前的博客中，我们深入介绍了如何安装与配置服务，如果你没看过先行回顾：<a href="https://budai.pages.dev/linux/nginx/basic/">Nginx代理与负载教程</a>。</p><blockquote><p>今天让我们更进一步，以具体的应用场景介绍 <code>Nginx</code> 的强大之处</p></blockquote><h4 id="1-服务代理"><a href="#1-服务代理" class="headerlink" title="1. 服务代理"></a>1. 服务代理</h4><p>在正向代理请求服务中，可将 <code>Nginx</code> 作为网络跳板机，代理客户端对外发起请求。从外部的角度，其只能看到代理服务器的信息，而无法感知其真正的客户端。</p><p>如下述配置即开放了 <code>8888</code> 端口作为代理服务，在客户端上配置此代理服务。当客户端发起请求后，将由代理服务对外发起请求，再将结果回传客户端，客户端在整个请求链路中对外都是无感知不可见。</p><pre class="line-numbers language-nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">8888</span><span class="token punctuation">;</span>    <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>        <span class="token keyword">proxy_pass</span> <span class="token variable">$scheme</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token variable">$http_host</span><span class="token variable">$request_uri</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$http_host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-服务藏匿"><a href="#2-服务藏匿" class="headerlink" title="2. 服务藏匿"></a>2. 服务藏匿</h4><p>与上述的场景类似，请求藏匿是双向的，反之同样可实现服务藏匿。经典的场景即在服务器 <code>A</code> 部署了某系统，但服务器上同时部署了其它服务你并不想对外暴露，当然你可以通过白名单及防火墙配置实现。</p><p>但你也可通过空白服务器 <code>B</code> 作为对外服务网关，由服务器 <code>B</code> 对外提供服务，将请求转发至服务器 <code>A</code>。以此方式服务器 <code>A</code> 完全属于内网服务，对于外部系统同样不可感知。</p><p>例如服务部署于 <code>192.168.0.1</code> 节点，那么我们即可在 <code>192.168.0.2</code> 节点中部署 <code>Nginx</code> 服务，并通过下述配置实现服务的反向代理至 <code>192.168.0.1</code> 节点。如此一来，外部系统只能通过 <code>192.168.0.2</code> 访问系统，我们便实现真正的服务藏匿。</p><pre class="line-numbers language-nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">5000</span><span class="token punctuation">;</span>            <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">4000</span><span class="token operator">/</span><span class="token punctuation">;</span>                       <span class="token keyword">proxy_set_header</span> HOST <span class="token variable">$host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-无感升级"><a href="#3-无感升级" class="headerlink" title="3. 无感升级"></a>3. 无感升级</h4><p>在上述的两类示例中，都是网络安全的场景下应用，但 <code>Nginx</code> 能力不仅如此，在服务性能提升上也依然强劲。</p><p>我们都知道通过 <code>upstream</code> 配置可轻松实现集群下多节点负载均衡，从而提供系统吞吐量。那在单体环境下，<code>Nginx</code> 优势是否就荡然无存？</p><p>答案很显然不是，即便在单节点服务中，利用 <code>upstream</code> 仍然能够实现不停机的服务升级，下面让我们来看一下具体如何实现。</p><p>例如在服务器中部署了 <code>192.168.0.1:4000</code> 节点，并以 <code>192.168.0.1:80</code> 端口对外开放服务，配置如下：</p><pre class="line-numbers language-nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>            <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">4000</span><span class="token operator">/</span><span class="token punctuation">;</span>                       <span class="token keyword">proxy_set_header</span> HOST <span class="token variable">$host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上述的配置通过 <code>upstream</code> 改造为下述配置方式：</p><pre class="line-numbers language-nginx"><code class="language-nginx"><span class="token keyword">http</span> <span class="token punctuation">{</span>    <span class="token keyword">upstream</span> host_list <span class="token punctuation">{</span>        <span class="token keyword">server</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">4000</span><span class="token operator">/</span> weight<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token keyword">server</span> <span class="token punctuation">{</span>        <span class="token keyword">listen</span>       <span class="token number">80</span><span class="token punctuation">;</span>        <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true"># 请求转发 host_list 服务列表</span>            <span class="token keyword">proxy_pass</span> host_list<span class="token punctuation">;</span>            <span class="token keyword">proxy_set_header</span> HOST <span class="token variable">$host</span><span class="token punctuation">;</span>            <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>            <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若此时需要操作系统服务升级，在不接入 <code>Nginx</code> 的场景下即停止旧服务然后等待新服务启动，而这整个过程中系统服务都处于宕机不可用。</p><p>而在 <code>Nginx</code> 介入的场景中，在上述的配置示例中，在不停止旧服务的前提下可部署新版服务，待新服务启动之后调整 <code>host_list</code> 配置如下：</p><pre class="line-numbers language-nginx"><code class="language-nginx"><span class="token keyword">upstream</span> host_list <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true"># 旧服务权重为 0 关闭</span>    <span class="token keyword">server</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">4000</span><span class="token operator">/</span> weight<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true"># 新服务配置权重开启服务</span>    <span class="token keyword">server</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">4001</span><span class="token operator">/</span> weight<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成配置之后通过 <code>reload</code> 重新加载配置使之生效：</p><pre class="line-numbers language-bash"><code class="language-bash">nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在整个服务切换过程中，用户仍可正常访问旧服务，避免了升级出现服务长时间宕机不可用的情况，极大提高了用户使用体验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Nginx&lt;/code&gt; 作为网络代理领域的绝对王者，在系统中的方方面面都能看到它的身影。&lt;/p&gt;
&lt;p&gt;在之前的博客中，我们深入介绍了如何安装与配置服务，如果你没看过先行回顾：&lt;a href=&quot;https://budai.pages.dev/linux/ngi</summary>
      
    
    
    
    <category term="Linux运维" scheme="https://budai.pages.dev/categories/Linux%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Linux" scheme="https://budai.pages.dev/tags/Linux/"/>
    
    <category term="Nginx" scheme="https://budai.pages.dev/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>数据库 Clob 类型详解</title>
    <link href="https://budai.pages.dev/db/clob/"/>
    <id>https://budai.pages.dev/db/clob/</id>
    <published>2025-08-05T16:00:00.000Z</published>
    <updated>2025-09-08T13:01:18.534Z</updated>
    
    <content type="html"><![CDATA[<p>在关系型数据库中，除了 <code>int</code> 与 <code>varchar</code> 等基础数据类型外，针对大数据属性提供了 <code>Clob</code> 与 <code>Blob</code> 类型，支持几十 <code>MB</code> 乃至 <code>GB</code> 级的数据存储。</p><p>今天就让我们深入剖析 <code>CLOB(character large object)</code> 类型，探究如何实现超长文本存储。</p><h3 id="一、MySQL库"><a href="#一、MySQL库" class="headerlink" title="一、MySQL库"></a>一、MySQL库</h3><h4 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h4><p>在 <code>MySQL</code> 数据库中，字符串内容时通常以 <code>VARCHAR</code> 类型存储，其最大支持为 <code>65535</code> 字节。</p><p>但需注意此处指字节而 <code>VARCHAR(n)</code> 中的 <code>n</code> 所指为字符，由于字符集的存在以 <code>utf8mb4</code> 为例，其单个字符占 <code>4</code> 个字节，因此其最大字符数约为 <code>65535/4 ≈ 16383</code>。</p><p>因此，在存储大文本时更多的采用 <code>Clob</code> 类型，在 <code>MySQL</code> 中以 <code>TEXT</code> 形式存在，可取范围如下：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">类型</td>        <th style="text-align: center;">长度</td>    </tr>    <tr>        <td style="text-align: center;">TINYTEXT</td>        <td style="text-align: center;">255 字节</td>    </tr>    <tr>        <td style="text-align: center;">TEXT</td>        <td style="text-align: center;">65535 字节 (约64KB)</td>    </tr>    <tr>        <td style="text-align: center;">MEDIUMTEXT</td>        <td style="text-align: center;">16777215 字节 (约16MB)</td>    </tr>    <tr>        <td style="text-align: center;">LONGTEXT</td>        <td style="text-align: center;">4294967295 字节 (约4GB)</td>    </tr></table></br><p>除了在新建表时声明外，也可通过 <code>ALTER</code> 关键字修改字段类型。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>table_name<span class="token operator">></span> <span class="token keyword">MODIFY</span> <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span>column_name<span class="token operator">></span> <span class="token keyword">LONGTEXT</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时在适用 <code>TEXT</code> 字段类型时需注意一点，其相应的查询等操作的索引将无效。</p><h3 id="二、Oracle库"><a href="#二、Oracle库" class="headerlink" title="二、Oracle库"></a>二、Oracle库</h3><h4 id="1-定义声明"><a href="#1-定义声明" class="headerlink" title="1. 定义声明"></a>1. 定义声明</h4><p><code>Oracle</code> 库中类似的，在 <code>11g</code> 版本中 <code>VARCHAR</code> 最大长度限制为 <code>4000</code>，同时编码字符集的存在一个汉字占据多个字节，实际长度不足 <code>2000</code>。</p><p>在 <code>Oracle</code> 中可通过下述命令查询当前数据库的字符集。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 查询当前字符集</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> v$nls_parameters <span class="token keyword">WHERE</span> parameter <span class="token operator">LIKE</span> <span class="token string">'%CHARACTERSET%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不同字符集下汉字对应的字节数参考下表：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">字符集</td>        <th style="text-align: center;">汉字限制</td>    </tr>    <tr>        <td style="text-align: center;">AL32UTF8</td>        <td style="text-align: center;">一个汉字 3 字节</td>    </tr>    <tr>        <td style="text-align: center;">ZHS16GBK</td>        <td style="text-align: center;">一个汉字 2 字节</td>    </tr></table></br><p>因此在若存储大文本内容，则需将字段类型声明为 <code>CLOB</code> 类型。</p><p>在插入或更新时，可由 <code>TO_CLOB()</code> 函数执行，但需注意此方式并不支持超过 <code>4000</code> 字符的数据操作。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> <span class="token operator">&lt;</span>table_name<span class="token operator">></span> <span class="token keyword">SET</span> <span class="token operator">&lt;</span>column_name<span class="token operator">></span> <span class="token operator">=</span> TO_CLOB<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-字段修改"><a href="#2-字段修改" class="headerlink" title="2. 字段修改"></a>2. 字段修改</h4><p>但与 <code>MySQL</code> 不同的是，<code>Oracle</code> 中由于底层实现不同，并不支持将 <code>VARCHAR</code> 类型直接修改为 <code>CLOB</code> 类型。因此，对于以存在的表若需要实现 <code>CLOB</code> 类型切换，需分为四步进行。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 1. 新增 CLOB 临时字段</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>table_name<span class="token operator">></span> <span class="token keyword">ADD</span> <span class="token operator">&lt;</span>temp_column<span class="token operator">></span> CLOB<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 2. 将目标字段内容赋值临时字段</span><span class="token keyword">UPDATE</span> <span class="token operator">&lt;</span>table_name<span class="token operator">></span> <span class="token keyword">SET</span> <span class="token operator">&lt;</span>temp_column<span class="token operator">></span> <span class="token operator">=</span> <span class="token operator">&lt;</span>origin_column<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 3. 删除目标字段</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>table_name<span class="token operator">></span> <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span>origin_column<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 4. 将临时字段改名为原目标字段</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>table_name<span class="token operator">></span> <span class="token keyword">RENAME</span> <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span>temp_column<span class="token operator">></span> <span class="token keyword">TO</span> <span class="token operator">&lt;</span>origin_column<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时需注意 <code>Oracle</code> 并不支持对 <code>Clob</code> 字段的函数与分组等操作。</p><p>如下述语句在执行时将失败返回 <code>ORA-00932: 数据类型不一致: 应为 -, 但却获得 CLOB</code>。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span>     clob_column<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">from</span>     tb_test <span class="token keyword">group</span> <span class="token keyword">by</span>     clob_column<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-代码集成"><a href="#3-代码集成" class="headerlink" title="3. 代码集成"></a>3. 代码集成</h4><p>在 <code>JDBC</code> 代码集成中，当字符数少于 <code>4000</code> 时可直接通过 <code>setString()</code> 方式赋值。</p><p>但若超过 <code>4000</code> 字符时，由于 <code>Oracle</code> 存在限制不支持超长的数据的直接增改，需创建 <code>Clob</code> 对象或通过 <code>setCharacterStream()</code> 方式保存，相应的代码示例如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clobDemo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    String sql <span class="token operator">=</span> <span class="token string">"INSERT INTO TB_TEST(ID, CONTENTS) VALUES (?, ?)"</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>            Connection conn <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            PreparedStatement stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        stmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建 Clob 对象</span>        Clob clob <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createClob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        clob<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Pretent this data is very long."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stmt<span class="token punctuation">.</span><span class="token function">setClob</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> clob<span class="token punctuation">)</span><span class="token punctuation">;</span>        stmt<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述示例以 <code>Clob</code> 对象为例，下面让我们看下以 <code>setCharacterStream()</code> 流的方式提交。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clobDemo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    String sql <span class="token operator">=</span> <span class="token string">"INSERT INTO TB_TEST(ID, CONTENTS) VALUES (?, ?)"</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>            Reader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringReader</span><span class="token punctuation">(</span><span class="token string">"Pretent this data is very long."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Connection conn <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            PreparedStatement stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        stmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 以流的方式写入</span>        stmt<span class="token punctuation">.</span><span class="token function">setCharacterStream</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> reader<span class="token punctuation">)</span><span class="token punctuation">;</span>        stmt<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在某些不支持 <code>CLOB</code> 赋值的情况下，可以采用分步取巧的方式实现 <code>CLOB</code> 数据保存。</p><p>实现思路上分为两步，手动开启事务并针对非 <code>CLOB</code> 字段执行新增或修改，完成后单独针对 <code>CLOB</code> 字段分批进行更新。在上述提到了 <code>Oracle</code> 不支持超过 <code>4000</code> 的直接增改，因此在考虑字符集的情况下可按照 <code>1000</code> 进行拆分，再分批通过 <code>||</code> 拼接原内容执行更新。</p><p>需要注意一点，由于此方式将命令拆解多步骤，因此需要通过 <code>setAutoCommit(false)</code> 关闭自动提交开启事务，当全部成功之后再提交事务，若期间发生错误则需进行回滚。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clobDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Connection conn <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        conn <span class="token operator">=</span> ConnectionUtil<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 关闭自动提交</span>        conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 先执行非 CLOB 字段新增</span>        String sql <span class="token operator">=</span> <span class="token string">"INSERT INTO TB_TEST(ID, NAME) VALUES (1, 'Alex')"</span><span class="token punctuation">;</span>        conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> interval <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        String data <span class="token operator">=</span> <span class="token string">"Pretent this data is very long."</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> strLength <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strLength<span class="token punctuation">;</span> i <span class="token operator">+=</span> interval<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 分批拼接更新</span>            String updateSql <span class="token operator">=</span> <span class="token string">"UPDATE TB_TEST SET CLOB_FIELD = CLOB_FIELD || ? WHERE ID = ?"</span><span class="token punctuation">;</span>            PreparedStatement stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>updateSql<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 分配截取</span>            String batch <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>strLength<span class="token punctuation">,</span> i <span class="token operator">+</span> interval<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> batch<span class="token punctuation">)</span><span class="token punctuation">;</span>            stmt<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 提交事务</span>        conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span>nonNull<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 发生异常时回滚事务</span>            conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在关系型数据库中，除了 &lt;code&gt;int&lt;/code&gt; 与 &lt;code&gt;varchar&lt;/code&gt; 等基础数据类型外，针对大数据属性提供了 &lt;code&gt;Clob&lt;/code&gt; 与 &lt;code&gt;Blob&lt;/code&gt; 类型，支持几十 &lt;code&gt;MB&lt;/code&gt; 乃至 </summary>
      
    
    
    
    <category term="数据库" scheme="https://budai.pages.dev/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Oracle" scheme="https://budai.pages.dev/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>系统鉴权设计详解</title>
    <link href="https://budai.pages.dev/java/spring/web/authentic/"/>
    <id>https://budai.pages.dev/java/spring/web/authentic/</id>
    <published>2025-08-03T16:00:00.000Z</published>
    <updated>2025-08-25T13:51:56.161Z</updated>
    
    <content type="html"><![CDATA[<p>在任意系统中，系统权限管理无疑都是尤为重要的环节。没有严格的权限管控，不用用户之间数据将相互暴露，后果不堪设想。</p><blockquote><p>今天，就让我们深入探讨一下如何在系统中实现完善的权限管理</p></blockquote><h3 id="一、名词解释"><a href="#一、名词解释" class="headerlink" title="一、名词解释"></a>一、名词解释</h3><p>在开始之前，让我们先了解一下系统鉴权中常涉及的一系列概念。</p><h4 id="1-数据越权"><a href="#1-数据越权" class="headerlink" title="1. 数据越权"></a>1. 数据越权</h4><p>数据越权故名思意即用户权限访问了不属于自身的资源，分为下述两类：</p><h5 id="1-垂直越权"><a href="#1-垂直越权" class="headerlink" title="(1) 垂直越权"></a>(1) 垂直越权</h5><p>垂直越权即访问高于自身级别的内容，如普通用户越权访问系统后台管理员资源。</p><h5 id="2-水平越权"><a href="#2-水平越权" class="headerlink" title="(2) 水平越权"></a>(2) 水平越权</h5><p>水平越权即访问到同级别资源内容，但内容并不属于你，如论坛系统中越权编辑或删除他人发布的贴子。</p><h4 id="2-鉴权模型"><a href="#2-鉴权模型" class="headerlink" title="2. 鉴权模型"></a>2. 鉴权模型</h4><p>针对上述提到的两类越权场景，实现鉴权的方式也有多类，在设计上通常集成使用。</p><h5 id="1-RBAC模型"><a href="#1-RBAC模型" class="headerlink" title="(1) RBAC模型"></a>(1) RBAC模型</h5><p><code>RBAC</code> 即基于角色访问控制 <code>(Role-Based Access Control)</code>，将系统资源绑定于不同的角色，再将用户与角色之间相关，通过校验用户的角色判断是否拥有权限。<br><img src="/album/loading.gif" data-original="/album/article/java/spring/auth/1.png"></p><p>在系统的功能设计中，通常在菜单权限设计中利用 <code>RBAC</code> 模型，从而实现功能间的隔离。</p><h5 id="2-ABAC模型"><a href="#2-ABAC模型" class="headerlink" title="(2) ABAC模型"></a>(2) ABAC模型</h5><p><code>ABAC</code> 则为基于属性的访问控制 <code>(Attribute-Based Access Control)</code>，即用户直接与资源属性进行绑定。<br><img src="/album/loading.gif" data-original="/album/article/java/spring/auth/2.png"></p><p>相对于 <code>RBAC</code> 而言虽然 <code>ABAC</code> 能够实现更精确的权限管理，但缺点也显而易见，产生的关联数据相对更多且实现更为复杂。因此，在核心数据中通常才基于 <code>ABAC</code> 模型设计。</p><h5 id="3-ReBAC模型"><a href="#3-ReBAC模型" class="headerlink" title="(3) ReBAC模型"></a>(3) ReBAC模型</h5><p><code>ReBAC</code> 为基于关系的访问控制 <code>(Relationship-Based Access Control)</code>，与 <code>RBAC</code> 有一定的类似。</p><p>与 <code>RBAC</code> 所不同的是在 <code>ReBAC</code> 中各级角色间存在关联。最为常见的即部门关系，同个部门下可共享权限，由此赋予部门负责人相应权限即可，部门成员即可继承权限，如下述图例：<br><img src="/album/loading.gif" data-original="/album/article/java/spring/auth/6.png"></p><p>如此设计的好处即无需像 <code>RBAC</code> 中单独为每个角色都绑定权限，极大节省了大量重复关联数据从而节省资源。</p><h3 id="二、功能权限"><a href="#二、功能权限" class="headerlink" title="二、功能权限"></a>二、功能权限</h3><p>在系统中主要包含两部分权限管理，功能菜单以及数据内容权限，让我们先以菜单权限入手。</p><h4 id="1-架构设计"><a href="#1-架构设计" class="headerlink" title="1. 架构设计"></a>1. 架构设计</h4><p>在菜单权限中设计中，常更倾向于 <code>RBAC</code> 由角色实现更优的管理。</p><p>不同的角色拥有不同的菜单权限，而每个用户又拥有不同的角色，通过角色将用户与菜单关联。<br><img src="/album/loading.gif" data-original="/album/article/java/spring/auth/3.png"></p><p>如此设计的好处在于可实现少量数据关联大量资源，若直接将用户与菜单执行关联，随着用户数量的增加将产生大量的重复数据，造成不必要的资源浪费。</p><h4 id="2-用户认证"><a href="#2-用户认证" class="headerlink" title="2. 用户认证"></a>2. 用户认证</h4><p>确定模型结构后，便可开始具体的代码实现设计。</p><p>最基础的当然莫属于用户登录认证了，在登录认证中常采用双认证机制。即权限认证与过期认证相结合，利用 <code>Spring Security</code> 实现用户账号认证，而 <code>JWT</code> 则用于实现过期登录认证。<br><img src="/album/loading.gif" data-original="/album/article/java/spring/auth/4.png"></p><p>关于具体的双认证实现细节这里不再展开，在之前的文章中已经详细分享过，感兴趣的话可去看一下：<a href="https://budai.pages.dev/java/spring/framework/security/">Spring Security权限认证实战</a>。</p><p>这里仅提一点，即登录通过之后将用户登录信息存入请求上下文中供后续使用。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setAuthentication</span><span class="token punctuation">(</span>UserDTO user<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Authentication authentic <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UsernamePasswordAuthenticationToken</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    SecurityContextHolder<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAuthentication</span><span class="token punctuation">(</span>authentic<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>Spring</code> 中可继承 <code>OncePerRequestFilter</code> 过滤器实现对请求的认证处理，其增强实现了 <code>Filter</code> 过滤器，保证在转发请求时每个请求也仍只会处理一次。</p><p>在 <code>doFilterInternal()</code> 读取请求认证头获取登录信息，当认证通过时存入 <code>Spring Security</code> 上下文环境中。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@RequiredArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TokenFilter</span> <span class="token keyword">extends</span> <span class="token class-name">OncePerRequestFilter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doFilterInternal</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> FilterChain filterChain<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        String token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"Token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">processNotPermit</span><span class="token punctuation">(</span><span class="token string">"Please login first."</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        UserDTO user<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 校验 JWT</span>            Claims claims <span class="token operator">=</span> jwtUtils<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>            String content <span class="token operator">=</span> claims<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"sub"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            user <span class="token operator">=</span> objectMapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> UserDTO<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">processNotPermit</span><span class="token punctuation">(</span><span class="token string">"Login fail."</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">processNotPermit</span><span class="token punctuation">(</span><span class="token string">"Invalid token."</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 校验通过</span>        SecurityManager<span class="token punctuation">.</span><span class="token function">setAuthentication</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        filterChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processNotPermit</span><span class="token punctuation">(</span>String msg<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"application/json;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">203</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>objectMapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>ResultData<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-权限管理"><a href="#3-权限管理" class="headerlink" title="3. 权限管理"></a>3. 权限管理</h4><p>根据上述设计图中的结构定义相应的用户、角色以及菜单关联内容后，便可开始具体的实现。</p><p>这里略去具体的业务层逻辑代码，仅演示如果通过 <code>Security</code> 实现管理。在这里利用 <code>Spring Security</code> 中 <code>@PreAuthorize</code> 注解的特性，其会接口执行前触发，我们便可前置校验用户是否满足权限。</p><p>按照提到的逻辑，让我们先定义权限校验的实现业务。逻辑上并不复杂，即读取请求上下文得到用户信息后查询对应的菜单权限，再与接口权限码相匹配是否包含。</p><p>完整的代码实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"pm"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RequiredArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PermitManager</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String SEPARATOR <span class="token operator">=</span> <span class="token string">","</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String ALL_PERMIT <span class="token operator">=</span> <span class="token string">"*.*"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> UserRoleService userRoleService<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 登录用户是否包含指定权限     *     * @param permit 菜单权限     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPermit</span><span class="token punctuation">(</span>String permit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Long userId <span class="token operator">=</span> <span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> menuPermits <span class="token operator">=</span> userRoleService<span class="token punctuation">.</span><span class="token function">getUserMenus</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>menuPermits<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ALL_PERMIT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 拥有所有菜单权限</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> menuPermits<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>permit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> Long <span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Long userId <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            UserDTO user <span class="token operator">=</span> <span class="token punctuation">(</span>UserDTO<span class="token punctuation">)</span> SecurityContextHolder<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">getAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">getPrincipal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            userId <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Not found user, message: {}"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> userId<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-接口设计"><a href="#4-接口设计" class="headerlink" title="4. 接口设计"></a>4. 接口设计</h4><p>完成上述工作之后便可在接口服务上绑定菜单权限，其中 <code>@PreAuthorize</code> 兼容 <code>IOC</code> 容器以 <code>bean</code> 形式调用，其配置格式为：<code>@bean.method(param)</code>。</p><p>如下述示例中即给订单查询接口绑定菜单权限 <code>order.query</code>，当请求接口时便会执行上述 <code>PermitManager</code> 中定义的校验逻辑。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api/order"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RequiredArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderResource</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> OrderService orderService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PreAuthorize</span><span class="token punctuation">(</span><span class="token string">"@pm.hasPermit('order.query')"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ResponseEntity<span class="token operator">&lt;</span>Order<span class="token operator">></span> <span class="token function">query</span><span class="token punctuation">(</span>String orderId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Order order <span class="token operator">=</span> orderService<span class="token punctuation">.</span><span class="token function">lambdaQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>Order<span class="token operator">:</span><span class="token operator">:</span>getOrderId<span class="token punctuation">,</span> orderId<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ResponseEntity<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注解以切面链路形式生效，当请求接口时将执行 <code>@PreAuthorize</code> 注解校验逻辑。</p><p>若返回 <code>false</code> 则表示权限不足，则不会继续执行方法体内容而会抛出 <code>AccessDeniedException</code> 异常，可通过 <code>@ExceptionHandler</code> 注解在全局异常中实现管理。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestControllerAdvice</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 监听异常请求并处理返回     */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"rawtypes"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ResultData <span class="token function">handleNotFoundException</span><span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ex <span class="token keyword">instanceof</span> <span class="token class-name">AccessDeniedException</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> ResultData<span class="token punctuation">.</span><span class="token function">denies</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ResultData<span class="token punctuation">.</span><span class="token function">failed</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、注解详解"><a href="#三、注解详解" class="headerlink" title="三、注解详解"></a>三、注解详解</h3><p>在上述中初步了解了 <code>@PreAuthorize</code> 使用方式，下面让我们进一步了解注解的使用。</p><p><code>Spring Security</code> 中针对校验提供了多个注解，其中较常用的有下述两个：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">注解</td>        <th style="text-align: center;">描述</td>    </tr>    <tr>        <td style="text-align: center;">@PreAuthorize</td>        <td style="text-align: center;">在接口前置执行校验。</td>    </tr>    <tr>        <td style="text-align: center;">@PostAuthorize</td>        <td style="text-align: center;">在接口后置执行校验。</td>    </tr></table></br><p>而除了之前提到的 <code>@bean.method(param)</code> 形式调用外，其支持多样灵活的表达式兼容，下面则分别进行介绍。</p><h4 id="1-对象引用"><a href="#1-对象引用" class="headerlink" title="1. 对象引用"></a>1. 对象引用</h4><p>其中最基础的方式即通过 <code>#</code> 引用获取当前接口入参内容，如下述即校验入参 <code>storeId</code> 值是否为 <code>123</code>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PreAuthorize</span><span class="token punctuation">(</span><span class="token string">"#storeId == '123'"</span><span class="token punctuation">)</span><span class="token keyword">public</span> Store <span class="token function">query</span><span class="token punctuation">(</span>String storeId<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当接口入参为对象时，<code>#</code> 表达式也支持 <code>obj.field</code> 的形式引用特定字段。</p><p>如下述中接口入参为 <code>Store</code> 类，则可以通过 <code>#store.storeId</code> 单独校验 <code>storeId</code> 属性。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Store</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long storeId<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@PreAuthorize</span><span class="token punctuation">(</span><span class="token string">"#store.storeId == '2'"</span><span class="token punctuation">)</span><span class="token keyword">public</span> Store <span class="token function">query</span><span class="token punctuation">(</span>Store store<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-参数别名"><a href="#2-参数别名" class="headerlink" title="2. 参数别名"></a>2. 参数别名</h4><p><code>Spring Security</code> 同时提供了 <code>@P</code> 实现别名配置，当声明的参数名称过长时，可实现代码简化。</p><p>如下述中方法入参字段为 <code>aVeryLongParameterNameOfStore</code>，而通过 <code>@P(&quot;s&quot;)</code> 即可实现参数重命名，在表达式中便可通过 <code>#s.storeId</code> 实现数据引用。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PreAuthorize</span><span class="token punctuation">(</span><span class="token string">"#s.storeId == '2'"</span><span class="token punctuation">)</span><span class="token keyword">public</span> Store <span class="token function">query</span><span class="token punctuation">(</span><span class="token annotation punctuation">@P</span><span class="token punctuation">(</span><span class="token string">"s"</span><span class="token punctuation">)</span> Store aVeryLongParameterNameOfStore<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-方法调用"><a href="#3-方法调用" class="headerlink" title="3. 方法调用"></a>3. 方法调用</h4><p>在之前的功能鉴权中也看到了可通过 <code>@</code> 实现方法的调用。</p><p>如声明了 <code>bean</code> 实例 <code>ts</code>，且包含方法 <code>isOk()</code>，内容如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"ts"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestServioce</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在表达式中则可通过 <code>@bean.method(param)</code> 格式调用，如下即通过 <code>@ts.isOk()</code> 调用上述方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PreAuthorize</span><span class="token punctuation">(</span><span class="token string">"@ts.isOk()"</span><span class="token punctuation">)</span><span class="token keyword">public</span> Store <span class="token function">query</span><span class="token punctuation">(</span>Store store<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-组合校验"><a href="#4-组合校验" class="headerlink" title="4. 组合校验"></a>4. 组合校验</h4><p>在表达式中也支持 <code>and</code> 和 <code>or</code> 关键字实现条件的组合内容校验。</p><p>如下即通过 <code>and</code> 实现 <code>storeId=1</code> 且 <code>name=AA</code> 的复合校验。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PreAuthorize</span><span class="token punctuation">(</span><span class="token string">"#s.storeId == '1' and #s.name == 'AA' "</span><span class="token punctuation">)</span><span class="token keyword">public</span> Store <span class="token function">query</span><span class="token punctuation">(</span>Store s<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四、数据权限"><a href="#四、数据权限" class="headerlink" title="四、数据权限"></a>四、数据权限</h3><p>了解上述基本内容后，那么接下来让我们来看一下如何实现数据权限管理。</p><h4 id="1-模型设计"><a href="#1-模型设计" class="headerlink" title="1. 模型设计"></a>1. 模型设计</h4><p>在数据鉴权中，显然 <code>RBAC</code> 角色模型不再适用，权限粒度不够将导致水平越权情况发生。</p><p>因此，在数据鉴权中，更多的是采用 <code>ABAC</code> 模型，将用户与数据直接进行关联，实现最小粒度控制。</p><p>换言之，即针对接口输入的内容比对是否拥有对应的资源权限。以商城系统为例，系统内存在多个店铺，每个用户拥有不同的店铺，用户与店铺之间则通过关联表直接关联。<br><img src="/album/loading.gif" data-original="/album/article/java/spring/auth/5.png"></p><h4 id="2-工厂设计"><a href="#2-工厂设计" class="headerlink" title="2. 工厂设计"></a>2. 工厂设计</h4><p>在代码设计上，为了适配同样的数据权限管理，这边定义了权限管理接口。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PermitHandler</span> <span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">hasPermit</span><span class="token punctuation">(</span>Object arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面以店铺权限校验为例，让我们编写对应的校验逻辑。</p><p>在实现上与刚才提到 <code>@PreAuthorize</code> 类似，读取 <code>Security</code> 上下文得到用户后查询用户拥有的店铺权限，并与输入数据进行比对。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"storePermitHandler"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RequiredArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StorePermitHandler</span> <span class="token keyword">implements</span> <span class="token class-name">PermitHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> StoreCache storeCache<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"store"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPermit</span><span class="token punctuation">(</span>Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Long userId <span class="token operator">=</span> SecurityManager<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>Long<span class="token operator">></span> storeIds <span class="token operator">=</span> storeCache<span class="token punctuation">.</span><span class="token function">readByUser</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> storeIds<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>Long<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-接口设计"><a href="#3-接口设计" class="headerlink" title="3. 接口设计"></a>3. 接口设计</h4><p>完成上述声明后，便可通过 <code>@PreAuthorize</code> 定义具体的接口权限。</p><p>如下述即定义需拥有 <code>store.query</code> 接口查询权限，同时查询的 <code>storeId</code> 需属于用户。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"{storeId}"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PreAuthorize</span><span class="token punctuation">(</span><span class="token string">"@pm.hasPermit('store.query') and @storePermitHandler.hasPermit(#storeId)"</span><span class="token punctuation">)</span><span class="token keyword">public</span> ResultData<span class="token operator">&lt;</span>Store<span class="token operator">></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String storeId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Store store <span class="token operator">=</span> storeService<span class="token punctuation">.</span><span class="token function">lambdaQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>Store<span class="token operator">:</span><span class="token operator">:</span>getStoreId<span class="token punctuation">,</span> storeId<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ResultData<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="五、手动管理"><a href="#五、手动管理" class="headerlink" title="五、手动管理"></a>五、手动管理</h3><p>在上述的示例中基于 <code>Spring Security</code> 自带注解及表达式可实现数据权限校验。</p><p>但在复杂的业务情况下，表达式复杂度将快速膨胀且无法灵活定义，因此自定义注解则更为合适，下面就具体分享如何设计实现。</p><h4 id="1-权限注解"><a href="#1-权限注解" class="headerlink" title="1. 权限注解"></a>1. 权限注解</h4><p>通过自定义权限注解，当方法参数标识了注解时执行相应的鉴权逻辑校验。</p><p>同样以刚才提到的用户店铺权限为例，声明注解 <code>@StorePermit</code> 作用于字段即方法，内容如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span>        ElementType<span class="token punctuation">.</span>PARAMETER<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">StorePermit</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，在之前的工厂实例基础上新增方法 <code>hasPermit(Annotation annotation, Object arg)</code> 实现校验逻辑，只有当注解存在且为 <code>@StorePermit</code> 时才触发校验。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@RequiredArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StorePermitHandler</span> <span class="token keyword">implements</span> <span class="token class-name">PermitHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPermit</span><span class="token punctuation">(</span>Annotation annotation<span class="token punctuation">,</span> Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>annotation<span class="token punctuation">)</span> <span class="token operator">||</span> annotation<span class="token punctuation">.</span><span class="token function">annotationType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> StorePermit<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">hasPermit</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-切面实现"><a href="#2-切面实现" class="headerlink" title="2. 切面实现"></a>2. 切面实现</h4><p>注解声明与校验逻辑编写完成之后，便可编写对应的切面实现。</p><p>在切面中通过环切遍历接口入参，若声明的接口入参标识的鉴权注解，则执行上述定义的鉴权逻辑。当鉴权不通过时，则返回 <code>403</code> 权限不足。</p><p>完整的切面实现代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@RequiredArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PermitAspect</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> PermitHandler<span class="token operator">></span> permitHandlerMap<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution (public * xyz.ibudai.authority.rest.*.*(..))"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"pointcut()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">around</span><span class="token punctuation">(</span>ProceedingJoinPoint joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        Method method <span class="token operator">=</span> <span class="token function">getMethod</span><span class="token punctuation">(</span>joinPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Annotation<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> annotations <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getParameterAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> annotations<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Object arg <span class="token operator">=</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Annotation annotation <span class="token operator">:</span> annotations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 遍历入参注解</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> PermitHandler<span class="token operator">></span> entry <span class="token operator">:</span> permitHandlerMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    PermitHandler handler <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">boolean</span> hasPermit <span class="token operator">=</span> handler<span class="token punctuation">.</span><span class="token function">lackPermit</span><span class="token punctuation">(</span>annotation<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasPermit<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 权限不足</span>                        <span class="token keyword">return</span> ResultData<span class="token punctuation">.</span><span class="token function">denies</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Lack %s permission of %s"</span><span class="token punctuation">,</span> handler<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 校验合法，放行</span>        <span class="token keyword">return</span> joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Method <span class="token function">getMethod</span><span class="token punctuation">(</span>ProceedingJoinPoint joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Signature signature <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>signature <span class="token keyword">instanceof</span> <span class="token class-name">MethodSignature</span> methodSignature<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果是代理对象，取真实方法</span>        Method method <span class="token operator">=</span> methodSignature<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                method <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> method<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-测试接口"><a href="#3-测试接口" class="headerlink" title="3. 测试接口"></a>3. 测试接口</h4><p>完成这一切准备工作之后，让我们以店铺查询接口为例。</p><p>定义店铺查询接口，在接口入参声明 <code>@StorePermit</code> 表示接口启用店铺鉴权检验。当请求接口时则会将输入的店铺与用户拥有的店铺比对，比对不通过则不会执行具体的方法业务。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api/store"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RequiredArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StoreResource</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> StoreService storeService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/get"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ResultData<span class="token operator">&lt;</span>Store<span class="token operator">></span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token annotation punctuation">@StorePermit</span> String storeId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Store store <span class="token operator">=</span> storeService<span class="token punctuation">.</span><span class="token function">lambdaQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>Store<span class="token operator">:</span><span class="token operator">:</span>getStoreId<span class="token punctuation">,</span> storeId<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ResultData<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述的示例可以看到，通过注解与切面结合的方式，在实现数据鉴权的同时简化鉴权逻辑，业务代码无需再关注相应的权限问题，极大简化了代码复杂度。</p><h3 id="六、后置鉴权"><a href="#六、后置鉴权" class="headerlink" title="六、后置鉴权"></a>六、后置鉴权</h3><h4 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h4><p>在上述场景中，不论是 <code>@PreAuthorize</code> 或自定义切面都针对前置校验，即根据输入执行对应的权限校验。</p><p>这类方案所依赖的前提即需要能通过输入内容直接或间接关联数据，如通过 <code>storeId</code> 进行精准查询。但当模糊搜索时此方案将失效，如输入条件为时间的范围搜索，此时无法通过输入直接过滤权限。</p><h4 id="2-方案设计"><a href="#2-方案设计" class="headerlink" title="2. 方案设计"></a>2. 方案设计</h4><p>针对此类场景，则需要采取后置权限校验，即针对结果进行鉴权管理，返回相应提示或剔除无权限数据。</p><p>在 <code>Spring Security</code> 同样提供了 <code>@PostAuthorize</code> 基于后置校验，通过 <code>returnObject</code> 引用结果，若返回 <code>false</code> 则会返回 <code>403</code> 无权限。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PostAuthorize</span><span class="token punctuation">(</span><span class="token string">"returnObject.storeId != null"</span><span class="token punctuation">)</span><span class="token keyword">public</span> Store <span class="token function">query</span><span class="token punctuation">(</span>String storeId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Store</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>采用 <code>@PostAuthorize</code> 存在弊端即模糊搜索时其只能实现全量放行或全量拦截，即当返回集合包含多条记录时无法实现仅返回有权限部分。</p><p>因此，对于部分剔除的场景，可以采用上述自定义切面方式处理，在切面中基于反射剔除无权限记录，实现逻辑类似此处不再赘述。</p><hr><p><strong>参考链接</strong></p><ol><li>仓库地址：<a href="https://github.com/BuDaiYouth/system-authority">system-authority</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在任意系统中，系统权限管理无疑都是尤为重要的环节。没有严格的权限管控，不用用户之间数据将相互暴露，后果不堪设想。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今天，就让我们深入探讨一下如何在系统中实现完善的权限管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、名词解</summary>
      
    
    
    
    <category term="Java Web" scheme="https://budai.pages.dev/categories/Java-Web/"/>
    
    
    <category term="Spring Boot" scheme="https://budai.pages.dev/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发锁实战</title>
    <link href="https://budai.pages.dev/java/thread/concurrency/"/>
    <id>https://budai.pages.dev/java/thread/concurrency/</id>
    <published>2025-06-28T16:00:00.000Z</published>
    <updated>2025-08-20T13:13:05.896Z</updated>
    
    <content type="html"><![CDATA[<p>在系统设计中，通常需面对着一个相对棘手的问题：同一数据的多端访问，即我们常说的数据并发。</p><p>通俗一点来讲，当同一份数据在同一时候被多端访问或修改时，其最终态将不可预测。由此衍生，针对此类场景有着丰富的解决方式，稍后让我们来一一盘点。</p><h3 id="一、多端并发"><a href="#一、多端并发" class="headerlink" title="一、多端并发"></a>一、多端并发</h3><p>对于并发问题，线程锁无疑是最趁手的工具，在以往的博客中分享过线程的基本定义与示例，今天就让我们将其应用于实际场景之中。</p><h4 id="1-业务场景"><a href="#1-业务场景" class="headerlink" title="1. 业务场景"></a>1. 业务场景</h4><p>首先让我们来假定一个业务场景，在系统中包含工单审批模块，审批环节多个用户都拥有审批权限，当用户操作审批之后将更新状态并完结工单。</p><p>如果你对业务足够敏感，在上述的的场景中便可发现一个问题，由于审批权限的开放给了多用户，当多个用户针对同一工单操作审批时，若无并发控制则工单终态将不可预测。</p><p>如两个用户同时发起操作，其中一个用户同意了工单，而另一用户拒绝了工单，最终工单的状态则可能为二者中的任意其一。这类不确定性对于业务功能而言显然不能接受，正确的效果应该是对其二中的一个用户返回审批中的消息提示等交互。</p><h4 id="2-基本思路"><a href="#2-基本思路" class="headerlink" title="2. 基本思路"></a>2. 基本思路</h4><p>针对上述提到的场景，先让我们来看一个较为经典的解决方案。</p><p>造成数据不可预测性的原因即多端访问问题，那所要实现的即限制同一个数据的并发访问，可采取下述步骤：</p><blockquote><ul><li>定义缓存容器，用于存储当前进行的事务；</li><li>用户发起操作时，读取进程中事务后并存入自身提交的事务；</li><li>执行操作对应的动作，同时比对事务是否操作中，若是则跳过；</li></ul></blockquote><p>对于缓存容器则有着丰富的选择，在单机环境下可选 <code>ConcurrentHashMap</code> 与 <code>SynchronizedSet</code> 等 JDK 自带线程安全容器。而对于集群部署服务，则可以使用 <code>Redis</code> 缓存数据库。</p><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h4><p>下面就将上述的实现方案转化为相应的代码实现。</p><p>在缓存容器上，这里选用了 <code>ConcurrentHashMap</code> 实例，由于其线程安全的特性则通过 <code>static</code> 声明为静态变量后便可作为缓存使用。而针对锁则使用 <code>ReentrantLock</code>，其基于 <code>Unsafe</code> 的 <code>CAS</code> 性能相对于 <code>synchronized</code> 关键字更优秀。</p><p>对应完整的实现代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrencyTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ReentrantLock locker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Set<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Data</span>    <span class="token annotation punctuation">@NoArgsConstructor</span>    <span class="token annotation punctuation">@AllArgsConstructor</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ActionTread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> String key<span class="token punctuation">;</span>        <span class="token keyword">private</span> Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> inputs<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> failed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> success <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> actives<span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 加锁读写缓存</span>                locker<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 读取激活状态数据</span>                    actives <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>Set<span class="token operator">:</span><span class="token operator">:</span>stream<span class="token punctuation">)</span>                            <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 记录自身提交数据</span>                    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    locker<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer ele <span class="token operator">:</span> inputs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 判断元素是否处理中，是则跳过</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>actives<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        failed<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 模拟业务耗时</span>                    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    success<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 释放缓存</span>                map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Key: {%s}, Failed: {%s}, Success: {%s}%n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> failed<span class="token punctuation">,</span> success<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一点需要注意，虽然 <code>Map</code> 容器为线程安全，但为了实现每个用户都读取都最新的缓存数据，针对缓存数据的读写两个步骤仍然需要加锁保证原子性。</p><p>以具体场景举例，<code>user1</code> 提交 <code>[1,2]</code> 后获取锁并读取缓存，此期间 <code>user2</code> 提交了 <code>[2,3]</code> 由于锁已经占用将进入阻塞，当 <code>user1</code> 写入缓存后释放锁，则 <code>user2</code> 成功获取锁并读取最新缓存得到 <code>user1</code> 提交的 <code>[1,2]</code>，后续则可基于此缓存数据判断处理。</p><p>在操作数据锁时注意一点，<code>lock()</code> 需在 <code>try</code> 代码块之外，原因在于若放置于 <code>try</code> 内当获取锁异常时，执行 <code>finally</code> 中的 <code>unlock()</code> 将再次抛出异常。</p><pre class="line-numbers language-java"><code class="language-java">locker<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do something</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    locker<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-测试用例"><a href="#4-测试用例" class="headerlink" title="4. 测试用例"></a>4. 测试用例</h4><p>完成对应的代码实现后让我们编写相应的用例进行测试。</p><p>分别定义三个用户提交了三个集合，集合内容相互交互。在操作提交后，预期的效果即 <code>Beth</code> 提交的 <code>3</code> 被 <code>Alex</code> 占用仅 <code>[4,5]</code> 成功，类似的 <code>Jack</code> 用户仅 <code>[6,7]</code> 成功。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionTread</span><span class="token punctuation">(</span><span class="token string">"Alex"</span><span class="token punctuation">,</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionTread</span><span class="token punctuation">(</span><span class="token string">"Beth"</span><span class="token punctuation">,</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionTread</span><span class="token punctuation">(</span><span class="token string">"Jack"</span><span class="token punctuation">,</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">started</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 阻塞主线程查看结果</span>    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">started</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Thread<span class="token operator">></span> threads<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread t <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行上述用例代码，可以看到输出的内容的与所预期效果一致。</p><pre class="line-numbers language-txt"><code class="language-txt">Key: {Alex}, Failed: {[]}, Success: {[1, 2, 3]}Key: {Beth}, Failed: {[3]}, Success: {[4, 5]}Key: {Jack}, Failed: {[5]}, Success: {[6, 7]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="二、单端并发"><a href="#二、单端并发" class="headerlink" title="二、单端并发"></a>二、单端并发</h3><h4 id="1-场景分析"><a href="#1-场景分析" class="headerlink" title="1. 场景分析"></a>1. 场景分析</h4><p>在刚才的示例中，我们解决了多用户的并发限制，实现了数据的原子性操作。</p><p>但在上述的场景下仍遗漏了一个环节，即缓存的管控依据以用户为维度，当同一用户针对同一数据发起连续操作时，限制此时将失效。</p><p>如同一用户提交 <code>[1,2,3]</code> 数据后并再次重复操作发起 <code>[1,2,3]</code>，显然此时第二次将被限制提交实现，但第二次提交失败退出执行 <code>map.remove()</code> 将导致数据的提前释放，若此时用户再次发起 <code>[1,2,3]</code> 将会绕过限制。</p><h4 id="2-代码改造"><a href="#2-代码改造" class="headerlink" title="2. 代码改造"></a>2. 代码改造</h4><p>因此，针对刚才提到的代码进行改造，在缓存容器上换成 <code>SynchronizedSet</code> 容器。</p><p>在缓存容器的读写部分，与之前的示例一致仍采用 <code>ReentrantLock</code> 锁方式实现。不同之处在于缓存的记录与释放，在释放缓存时仅移除成功部分，因为失败部分数据表明在线程中正在操作，应由发起方进行资源释放。</p><p>另外需注意一点，由于每次只释放成功部分数据，为防止意料外的异常崩溃在 <code>catch</code> 中当捕获程序异常时，仍需按提交内容全量释放，防止资源未正确清空释放。</p><p>改造后对应完整的实现代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrencyTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ReentrantLock locker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedSet</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Data</span>    <span class="token annotation punctuation">@NoArgsConstructor</span>    <span class="token annotation punctuation">@AllArgsConstructor</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ActionTest</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> String key<span class="token punctuation">;</span>        <span class="token keyword">private</span> Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> inputs<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> failed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> success <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> hasException <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> actives<span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 加锁读写缓存</span>                locker<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 复制缓存，切断引用</span>                    actives <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>                    set<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    locker<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer ele <span class="token operator">:</span> inputs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 判断元素是否处理中，是则跳过</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>actives<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        failed<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 模拟业务耗时</span>                    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    success<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 发生异常按提交内容清空</span>                hasException <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                set<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasException<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 仅清除成功内容</span>                    set<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Key: {%s}, Failed: {%s}, Success: {%s}%n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> failed<span class="token punctuation">,</span> success<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-测试用例"><a href="#3-测试用例" class="headerlink" title="3. 测试用例"></a>3. 测试用例</h4><p>同样的，按照刚才提到的单用户并发编写相应的测试用例代码，内容如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionTread</span><span class="token punctuation">(</span><span class="token string">"Alex"</span><span class="token punctuation">,</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionTread</span><span class="token punctuation">(</span><span class="token string">"Alex"</span><span class="token punctuation">,</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionTread</span><span class="token punctuation">(</span><span class="token string">"Alex"</span><span class="token punctuation">,</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">started</span><span class="token punctuation">(</span>List<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行上述用例代码，可以看到后续两次重复提交都能按照设计被成功拦截。</p><pre class="line-numbers language-txt"><code class="language-txt">Key: {Alex}, Failed: {[1, 2, 3]}, Success: {[]}Key: {Alex}, Failed: {[1, 2]}, Success: {[]}Key: {Alex}, Failed: {[]}, Success: {[1, 2, 3]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="三、队列应用"><a href="#三、队列应用" class="headerlink" title="三、队列应用"></a>三、队列应用</h3><h4 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1. 思路分析"></a>1. 思路分析</h4><p>除了上述提到的基于缓存容器之外，针对并发场景也可利用队列先进先出的特性实现。</p><p>首先让我们从根本上来看可以发现数据不可预测是由于并发导致，那么如果从程序上避免并发问题即迎刃而解。</p><p>那又应该如何消除并发呢？原理其实并不复杂，通过队列将多端输入内容入列，再由统一的消费者读取队列后执行相应的操作，由此便从流程上消除了并发场景。</p><h4 id="2-数据生产"><a href="#2-数据生产" class="headerlink" title="2. 数据生产"></a>2. 数据生产</h4><p>下面就将对应的方案转为实际代码实现。</p><p>同样的，对于数据的读写仍需要涉及 <code>ReentrantLock</code> 保存原子性，由于不再需要缓存容器，这里选择了 <code>JDK</code> 中自带的 <code>LinkedBlockingQueue</code> 阻塞队列实例。倘若在集群环境中，则可替换选择 <code>RabbitMQ</code> 及 <code>Kafka</code> 等常见消息队列作为载体。</p><p>当用户提交操作时，由生产者将数据发送至阻塞队列，代码实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrencyTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ReentrantLock locker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> LinkedBlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Data</span>    <span class="token annotation punctuation">@NoArgsConstructor</span>    <span class="token annotation punctuation">@AllArgsConstructor</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> inputs<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            locker<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 提交内容入队</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>String ele <span class="token operator">:</span> inputs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                locker<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-数据消费"><a href="#3-数据消费" class="headerlink" title="3. 数据消费"></a>3. 数据消费</h4><p>在消费者方面，即启动守护线程监听队列数据，当存在数据写入时则由 <code>take()</code> 读取内容，再判断是否元素是否处理过即可。</p><p>在这里仍通过 <code>ConcurrentHashMap</code> 记录数据的处理次数，由于此时消费者仅单线程，理论上使用非线程安全容器也可，消费者逻辑代码实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrencyTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 读取队列</span>                    String ele <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 判断是否处理过</span>                    Integer count <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 记录数据操作次数</span>                    map<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>ele<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Integer<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-测试用例-1"><a href="#4-测试用例-1" class="headerlink" title="4. 测试用例"></a>4. 测试用例</h4><p>完成后编写相应的测试用例，通过生产者提交数据，每次提交内容都包含重复数据。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Thread<span class="token operator">></span> threads <span class="token operator">=</span> List<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread t <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行程序后可以看到输出内容每个元素计数器仅 <code>1</code>，对于重复部分能够成功过滤。</p><pre class="line-numbers language-txt"><code class="language-txt">{a=1, b=1, c=1, d=1}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="四、线程池集成"><a href="#四、线程池集成" class="headerlink" title="四、线程池集成"></a>四、线程池集成</h3><h4 id="1-方案设计"><a href="#1-方案设计" class="headerlink" title="1. 方案设计"></a>1. 方案设计</h4><p>在上一点的队列方案中，通过 <code>LinkedBlockingQueue</code> 巧妙实现了异步串行功能。而除此方式外，通过线程池同样可实现类似效果，下面让我们来具体看下如何实现。</p><p>我们都知道影响线程池执行任务策略的核心的参数无非就是核心线程数 <code>(CorePoolSize)</code> 以及最大线程数 <code>(MaxPoolSize)</code>，而为了保证串行则可将二者都配置为 <code>1</code>，保证整个过程中仅允许单个线程处理任务。</p><p>同时，将 <code>QueueCapacity</code> 设置为预期任务量的 <code>1.5-2</code> 倍之间，由于 <code>MaxPoolSize=1</code> 因此永远不会创建新线程，提交的任务都将进入缓冲队列等待。而基于队列先进先出的特性，便实现了异步串行阻塞处理，达到了上述队列中的同样效果。</p><h4 id="2-集成示例"><a href="#2-集成示例" class="headerlink" title="2. 集成示例"></a>2. 集成示例</h4><p>下面让演示如何在 <code>Spring</code> 工程中实现上述方案，初始化 <code>ThreadPoolTaskExecutor</code> 线程池对象，设置核心线程数和最大线程数分别都为 <code>1</code>，代码示例如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ThreadPoolTaskExecutor <span class="token function">taskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadPoolTaskExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">setQueueCapacity</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 超出队列由用户线程执行</span>        executor<span class="token punctuation">.</span><span class="token function">setRejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> executor<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里着重介绍一下如何确定 <code>QueueCapacity</code> 取值。根据业务场景确定并发数量大小，如单次发起数量达到 100，则合理的队列大小应为 <code>150-200</code> 之间，即上述提到 <code>1.5-2</code> 倍。</p><p>其核心在于保证不会无限制的接收任务导致 OOM，同样也不会因为队列过小用户线程自行执行导致的任务并发，使得提交的任务都能进行队列等待，由单线程按照先进先出 <code>(FIFO)</code> 的顺序消费线程任务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在系统设计中，通常需面对着一个相对棘手的问题：同一数据的多端访问，即我们常说的数据并发。&lt;/p&gt;
&lt;p&gt;通俗一点来讲，当同一份数据在同一时候被多端访问或修改时，其最终态将不可预测。由此衍生，针对此类场景有着丰富的解决方式，稍后让我们来一一盘点。&lt;/p&gt;
&lt;h3 id=&quot;一、</summary>
      
    
    
    
    <category term="线程并发" scheme="https://budai.pages.dev/categories/%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="JAVA" scheme="https://budai.pages.dev/tags/JAVA/"/>
    
    <category term="多线程" scheme="https://budai.pages.dev/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>NLLB 翻译模型实战</title>
    <link href="https://budai.pages.dev/pyhton/tranlator/"/>
    <id>https://budai.pages.dev/pyhton/tranlator/</id>
    <published>2025-06-09T16:00:00.000Z</published>
    <updated>2025-12-21T03:09:52.035Z</updated>
    
    <content type="html"><![CDATA[<p><code>Hugging Face</code> 与 <code>GitHub</code> 相似，专注于 <code>AI</code> 模型领域的开源社区，拥有丰富的模型可实现快速集成。社区吸引了众多的优秀的开发者及公司机构，源源不断的产出优秀成果。</p><p>今天，就让我们通过 <code>Python</code> 集成 <code>facebook</code> 开源的翻译模型，快速打造专属翻译引擎，以 <code>API</code> 接口为媒介为应用提供基础翻译服务。</p><h3 id="一、基本准备"><a href="#一、基本准备" class="headerlink" title="一、基本准备"></a>一、基本准备</h3><h4 id="1-模型下载"><a href="#1-模型下载" class="headerlink" title="1. 模型下载"></a>1. 模型下载</h4><p><code>nllb-200-distilled-600M</code> 模型是由 <code>Facebook</code> 开源的 <code>AI</code> 翻译模型，模型支持 <code>200</code> 种语言翻译。</p><p>开始之前需要下载相应的模型文件，访问 <code>nllb</code> 模型相应的仓库下载图中标注内容：<a href="https://huggingface.co/facebook/nllb-200-distilled-600M/tree/main">nllb-200-distilled-600M</a>。<br><img src="/album/loading.gif" data-original="/album/article/python/engine/1.png"></p><h4 id="2-依赖下载"><a href="#2-依赖下载" class="headerlink" title="2. 依赖下载"></a>2. 依赖下载</h4><p>新建 <code>Python</code> 项目并安装下述依赖，服务将通过 <code>torch</code> 加载模型，并基于 <code>fastapi</code> 框架以 <code>API</code> 接口形式对外开放服务。同时，利用 <code>PyYAML</code> 库实现 <code>yml</code> 文件内容配置化，并通过 <code>langdetect</code> 语言库实现语言检测。</p><p>新建 <code>requirements.txt</code> 依赖文件，类库依赖内容如下：</p><pre class="line-numbers language-txt"><code class="language-txt">fastapi==0.110.0uvicorn[standard]==0.29.0transformers==4.39.3torch>=1.13.1sentencepiece==0.1.99protobuf==3.20.3pydantic==1.10.13PyYAML~=6.0.2langdetect~=1.0.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、系统配置"><a href="#二、系统配置" class="headerlink" title="二、系统配置"></a>二、系统配置</h3><h4 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h4><p>为了更好的方便系统维护，利用 <code>PyYAML</code> 库可实现 <code>yml</code> 文件的解析，实现配置化管理。</p><p>新建 <code>application.yml</code> 配置文件，定义对应的接口服务信息，以及默认上述下载后的模型存储路径。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">app</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> Daily Word  <span class="token key atrule">description</span><span class="token punctuation">:</span> Word Translation  <span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token number">1.0</span>  <span class="token key atrule">host</span><span class="token punctuation">:</span> 127.0.0.1  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span><span class="token key atrule">model</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"D:/Workspace/Model"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-实体定义"><a href="#2-实体定义" class="headerlink" title="2. 实体定义"></a>2. 实体定义</h4><p><code>@dataclass</code> 是 <code>3.7+</code> 版本标准库中的轻量级数据容器，提供了基础的对象定义。</p><p>这里通过类对象更便捷的交互配置文件，分别新建 <code>AppConfig.py</code> 与 <code>ModelConfig.py</code> 文件，文件内容如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> dataclasses <span class="token keyword">import</span> dataclass@dataclass<span class="token keyword">class</span> <span class="token class-name">AppConfig</span><span class="token punctuation">:</span>    name<span class="token punctuation">:</span> str    description<span class="token punctuation">:</span> str    version<span class="token punctuation">:</span> str    host<span class="token punctuation">:</span> str    port<span class="token punctuation">:</span> int@dataclass<span class="token keyword">class</span> <span class="token class-name">ModelConfig</span><span class="token punctuation">:</span>    path<span class="token punctuation">:</span> str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-文件加载"><a href="#2-文件加载" class="headerlink" title="2. 文件加载"></a>2. 文件加载</h4><p>定义类文件后便可通过 <code>yaml.safe_load(file)</code> 方法加载 <code>yml</code> 配置文件。</p><p>完整实现代码如下，后续便可访问 <code>get_app_config()</code> 与 <code>get_model_config()</code> 方法或者配置信息。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> yaml<span class="token keyword">import</span> os<span class="token keyword">from</span> config<span class="token punctuation">.</span>AppConfig <span class="token keyword">import</span> AppConfig<span class="token keyword">from</span> config<span class="token punctuation">.</span>ModelConfig <span class="token keyword">import</span> ModelConfig<span class="token comment" spellcheck="true"># 配置文件</span><span class="token keyword">def</span> <span class="token function">load_config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 读取相对路径</span>    base_dir <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span>__file__<span class="token punctuation">)</span><span class="token punctuation">)</span>    config_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>base_dir<span class="token punctuation">,</span> <span class="token string">'../../config/application.yml'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 文件存在判断</span>    <span class="token keyword">if</span> <span class="token operator">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>config_path<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> FileNotFoundError<span class="token punctuation">(</span>f<span class="token string">"Not found config file of: {config_path}"</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span>config_path<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> file<span class="token punctuation">:</span>        <span class="token keyword">return</span> yaml<span class="token punctuation">.</span>safe_load<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 加载配置文件</span>_config_data <span class="token operator">=</span> load_config<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取系统配置</span><span class="token keyword">def</span> <span class="token function">get_app_config</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> AppConfig<span class="token punctuation">:</span>    app_data <span class="token operator">=</span> _config_data<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> AppConfig<span class="token punctuation">(</span><span class="token operator">**</span>app_data<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取模型配置</span><span class="token keyword">def</span> <span class="token function">get_model_config</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ModelConfig<span class="token punctuation">:</span>    model_data <span class="token operator">=</span> _config_data<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'model'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ModelConfig<span class="token punctuation">(</span><span class="token operator">**</span>model_data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、引擎实现"><a href="#三、引擎实现" class="headerlink" title="三、引擎实现"></a>三、引擎实现</h3><h4 id="1-语言检测"><a href="#1-语言检测" class="headerlink" title="1. 语言检测"></a>1. 语言检测</h4><p>通过 <code>langdetect</code> 库可实现文本语言类型检测，服务调用时则无需手动声明类型，可由系统自行匹配。</p><p>但 <code>langdetect</code> 语言表示与 <code>nllb</code> 模型语言表达并不一致，因此系统内仍需要维护一份语言映射表，此处定义的方法作用描述参考下表：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">方法</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">detect_lang()</td>        <td style="text-align: center;">检测文本语言。</td>    </tr>    <tr>        <td style="text-align: center;">convert_type()</td>        <td style="text-align: center;">转化映射语言类型。</td>    </tr>    <tr>        <td style="text-align: center;">reverse_type()</td>        <td style="text-align: center;">反转映射语言类型。</td>    </tr></table></br><p>完整实现代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> langdetect <span class="token keyword">import</span> detectLANG_CODE_MAP <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'zh'</span><span class="token punctuation">:</span> <span class="token string">'zho_Hans'</span><span class="token punctuation">,</span>    <span class="token string">'en'</span><span class="token punctuation">:</span> <span class="token string">'eng_Latn'</span><span class="token punctuation">,</span>    <span class="token string">'fr'</span><span class="token punctuation">:</span> <span class="token string">'fra_Latn'</span><span class="token punctuation">,</span>    <span class="token string">'de'</span><span class="token punctuation">:</span> <span class="token string">'deu_Latn'</span><span class="token punctuation">,</span>    <span class="token string">'ja'</span><span class="token punctuation">:</span> <span class="token string">'jpn_Jpan'</span><span class="token punctuation">,</span>    <span class="token string">'ko'</span><span class="token punctuation">:</span> <span class="token string">'kor_Hang'</span><span class="token punctuation">,</span>    <span class="token string">'es'</span><span class="token punctuation">:</span> <span class="token string">'spa_Latn'</span><span class="token punctuation">}</span>REVERSE_LANG_CODE_MAP <span class="token operator">=</span> <span class="token punctuation">{</span>v<span class="token punctuation">:</span> k <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> LANG_CODE_MAP<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 语言检测</span><span class="token keyword">def</span> <span class="token function">detect_lang</span><span class="token punctuation">(</span>text<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        detected <span class="token operator">=</span> detect<span class="token punctuation">(</span>text<span class="token punctuation">)</span>        <span class="token keyword">if</span> detected <span class="token operator">==</span> <span class="token string">"zh-cn"</span> <span class="token operator">or</span> detected <span class="token operator">==</span><span class="token string">"zh-tw"</span><span class="token punctuation">:</span>            detected <span class="token operator">=</span> <span class="token string">"zh"</span>        <span class="token comment" spellcheck="true"># 类型映射</span>        <span class="token keyword">return</span> LANG_CODE_MAP<span class="token punctuation">.</span>get<span class="token punctuation">(</span>detected<span class="token punctuation">,</span> <span class="token string">'eng_Latn'</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> Exception<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'eng_Latn'</span><span class="token comment" spellcheck="true"># 类型转化</span><span class="token keyword">def</span> <span class="token function">convert_type</span><span class="token punctuation">(</span>lang_type<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> LANG_CODE_MAP<span class="token punctuation">[</span>lang_type<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>        <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span>f<span class="token string">"Unsupported language type: {lang_type}"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 类型反转</span><span class="token keyword">def</span> <span class="token function">reverse_type</span><span class="token punctuation">(</span>code<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> REVERSE_LANG_CODE_MAP<span class="token punctuation">[</span>code<span class="token punctuation">]</span>    <span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>        <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span>f<span class="token string">"Unsupported language code: {code}"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-模型加载"><a href="#2-模型加载" class="headerlink" title="2. 模型加载"></a>2. 模型加载</h4><p>下载 <code>torch</code> 与 <code>transformers</code> 类库后，便可开箱即用加载上述下载完成的模型。</p><p>代码逻辑十分简洁，其中 <code>local_files_only=True</code> 表示模型读取本地文件，当然也支持读取线上资源，但本地加载模型相对速度更快。</p><p>需注意一点，本地加载 <code>NLLB</code> 模型需要机器内存至少不低于 <code>4G</code>。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> transformers <span class="token keyword">import</span> AutoTokenizer<span class="token punctuation">,</span> AutoModelForSeq2SeqLM<span class="token keyword">from</span> pathlib <span class="token keyword">import</span> Path<span class="token comment" spellcheck="true"># 导入工具</span><span class="token keyword">from</span> tool<span class="token punctuation">.</span>ConfigTool <span class="token keyword">import</span> get_model_config<span class="token comment" spellcheck="true"># 配置加载</span>model_config <span class="token operator">=</span> get_model_config<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 模型加载</span>model_path <span class="token operator">=</span> Path<span class="token punctuation">(</span>model_config<span class="token punctuation">.</span>path<span class="token punctuation">)</span>model <span class="token operator">=</span> AutoModelForSeq2SeqLM<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>model_path<span class="token punctuation">,</span> local_files_only<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>tokenizer <span class="token operator">=</span> AutoTokenizer<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>model_path<span class="token punctuation">,</span> local_files_only<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四、接口服务"><a href="#四、接口服务" class="headerlink" title="四、接口服务"></a>四、接口服务</h3><h4 id="1-实体定义"><a href="#1-实体定义" class="headerlink" title="1. 实体定义"></a>1. 实体定义</h4><p>在上述的基本工作完成后，便可编写对应的接口服务。同样的，为接口的出入参定义相应的实体类 <code>RequestDTO</code> 与 <code>ResponseDTO</code>。</p><p>可以看到此处定义方式并非通过 <code>@dataclass</code> 实现，而是由第三方类库 <code>Pydantic</code> 的 <code>BaseModel</code> 声明。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pydantic <span class="token keyword">import</span> BaseModel <span class="token keyword">class</span> <span class="token class-name">RequestDTO</span><span class="token punctuation">(</span>BaseModel<span class="token punctuation">)</span><span class="token punctuation">:</span>    text<span class="token punctuation">:</span> str    targetType<span class="token punctuation">:</span> str<span class="token keyword">class</span> <span class="token class-name">ResponseDTO</span><span class="token punctuation">(</span>BaseModel<span class="token punctuation">)</span><span class="token punctuation">:</span>    sourceType<span class="token punctuation">:</span> str    sourceText<span class="token punctuation">:</span> str    targetType<span class="token punctuation">:</span> str    targetText<span class="token punctuation">:</span> str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Python</code> 标准库中自带的 <code>@dataclass</code> 虽然能够实现类定义，但功能简单适合简单的数据结构。而 <code>BaseModel</code> 额外包含了类型自动转化、<code>Json</code> 格式解析与导出等功能，提供了强大的数据模型。</p><p>例如下述示例中，由 <code>BaseModel</code> 定义的 <code>User2</code> 类成员变量 <code>age</code> 类型为 <code>int</code>，在输入字符串时将会自动转化格式，而 <code>@dataclass</code> 则无法实现。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> dataclasses <span class="token keyword">import</span> dataclass@dataclass<span class="token keyword">class</span> <span class="token class-name">User1</span><span class="token punctuation">:</span>    name<span class="token punctuation">:</span> str    age<span class="token punctuation">:</span> intuser1 <span class="token operator">=</span> User1<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token string">"30"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># name='Alice', age='30'</span><span class="token keyword">print</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token keyword">from</span> pydantic <span class="token keyword">import</span> BaseModel<span class="token keyword">class</span> <span class="token class-name">User2</span><span class="token punctuation">(</span>BaseModel<span class="token punctuation">)</span><span class="token punctuation">:</span>    name<span class="token punctuation">:</span> str    age<span class="token punctuation">:</span> intuser2 <span class="token operator">=</span> User2<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token string">"30"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># name='Alice' age=30</span><span class="token keyword">print</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时若 <code>age</code> 属性赋值非数字或非数据字符串将提示下述错误，因为 <code>BaseModel</code> 自带类型校验。</p><p>因此，在系统设计中 <code>BaseModel</code> 更多的应用于强业务逻辑中，如常见的方法与接口的出入参。</p><pre class="line-numbers language-txt"><code class="language-txt">pydantic.error_wrappers.ValidationError: 1 validation error for User2age  value is not a valid integer (type=type_error.integer)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-接口定义"><a href="#2-接口定义" class="headerlink" title="2. 接口定义"></a>2. 接口定义</h4><p>接下来便可基于 <code>fastapi</code> 框架编写对应的接口服务。</p><p>在上述内容中我们已经各个功能点拆分，接下要做的组装即可，步骤逻辑如下：</p><blockquote><ul><li>检测输入文本语言；</li><li>校验语言是否支持；</li><li>调用翻译模型服务；</li><li>封装翻译结果返回；</li></ul></blockquote><p>相对应的完整实现代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> fastapi <span class="token keyword">import</span> APIRouter<span class="token punctuation">,</span> HTTPException<span class="token keyword">from</span> schemas<span class="token punctuation">.</span>RequestDTO <span class="token keyword">import</span> RequestDTO<span class="token keyword">from</span> schemas<span class="token punctuation">.</span>ResponseDTO <span class="token keyword">import</span> ResponseDTO<span class="token keyword">from</span> tool<span class="token punctuation">.</span>LanguageTool <span class="token keyword">import</span> detect_lang<span class="token punctuation">,</span> convert_type<span class="token punctuation">,</span> reverse_type<span class="token keyword">from</span> tool<span class="token punctuation">.</span>ModelTool <span class="token keyword">import</span> model<span class="token punctuation">,</span> tokenizer<span class="token comment" spellcheck="true"># 导出接口</span>router <span class="token operator">=</span> APIRouter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 接口服务</span>@router<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">"/nllb/translate"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">translate</span><span class="token punctuation">(</span>req<span class="token punctuation">:</span> RequestDTO<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ResponseDTO<span class="token punctuation">:</span>    source_text <span class="token operator">=</span> req<span class="token punctuation">.</span>text    <span class="token comment" spellcheck="true"># 检测输入语言</span>    source_type <span class="token operator">=</span> detect_lang<span class="token punctuation">(</span>source_text<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 语言类型校验</span>    target_type <span class="token operator">=</span> convert_type<span class="token punctuation">(</span>req<span class="token punctuation">.</span>targetType<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token operator">not</span> target_type <span class="token operator">or</span> target_type <span class="token operator">not</span> <span class="token keyword">in</span> tokenizer<span class="token punctuation">.</span>lang_code_to_id<span class="token punctuation">:</span>        <span class="token keyword">raise</span> HTTPException<span class="token punctuation">(</span>status_code <span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">,</span> detail <span class="token operator">=</span> f<span class="token string">"Unsupported target language: {target_type}"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 语言类型一致直接返回</span>    <span class="token keyword">if</span> source_type <span class="token operator">==</span> target_type<span class="token punctuation">:</span>         <span class="token keyword">return</span> ResponseDTO<span class="token punctuation">(</span>            sourceType <span class="token operator">=</span> req<span class="token punctuation">.</span>targetType<span class="token punctuation">,</span>            sourceText <span class="token operator">=</span> source_text<span class="token punctuation">,</span>            targetType <span class="token operator">=</span> req<span class="token punctuation">.</span>targetType<span class="token punctuation">,</span>            targetText <span class="token operator">=</span> source_text        <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 翻译内容</span>    tokenizer<span class="token punctuation">.</span>src_lang <span class="token operator">=</span> source_type    inputs <span class="token operator">=</span> tokenizer<span class="token punctuation">(</span>source_text<span class="token punctuation">,</span> return_tensors<span class="token operator">=</span><span class="token string">"pt"</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> truncation<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        outputs <span class="token operator">=</span> model<span class="token punctuation">.</span>generate<span class="token punctuation">(</span>            <span class="token operator">**</span>inputs<span class="token punctuation">,</span>            forced_bos_token_id <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>convert_tokens_to_ids<span class="token punctuation">(</span>target_type<span class="token punctuation">)</span><span class="token punctuation">,</span>            max_length<span class="token operator">=</span><span class="token number">256</span>        <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 解码输出</span>    result <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>batch_decode<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> skip_special_tokens<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 返回结果</span>    <span class="token keyword">return</span> ResponseDTO<span class="token punctuation">(</span>        <span class="token comment" spellcheck="true"># 反转类型</span>        sourceType <span class="token operator">=</span> reverse_type<span class="token punctuation">(</span>source_type<span class="token punctuation">)</span><span class="token punctuation">,</span>        sourceText <span class="token operator">=</span> source_text<span class="token punctuation">,</span>        targetType <span class="token operator">=</span> req<span class="token punctuation">.</span>targetType<span class="token punctuation">,</span>        targetText <span class="token operator">=</span> result    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-启动入口"><a href="#4-启动入口" class="headerlink" title="4. 启动入口"></a>4. 启动入口</h4><p>完成这一切工作之后，新建 <code>main.py</code> 文件编写程序入口。</p><p>代码实现并不复杂，定义 <code>FastAPI</code> 相应的信息后挂载上述定义的接口服务。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> uvicorn<span class="token keyword">from</span> fastapi <span class="token keyword">import</span> FastAPI<span class="token keyword">from</span> tool<span class="token punctuation">.</span>ConfigTool <span class="token keyword">import</span> get_app_config<span class="token keyword">from</span> api<span class="token punctuation">.</span>WordResource <span class="token keyword">import</span> router <span class="token keyword">as</span> translate_router<span class="token comment" spellcheck="true"># 系统信息</span>app_config <span class="token operator">=</span> get_app_config<span class="token punctuation">(</span><span class="token punctuation">)</span>app <span class="token operator">=</span> FastAPI<span class="token punctuation">(</span>    title <span class="token operator">=</span> app_config<span class="token punctuation">.</span>name<span class="token punctuation">,</span>    description <span class="token operator">=</span> app_config<span class="token punctuation">.</span>description<span class="token punctuation">,</span>    version <span class="token operator">=</span> app_config<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 挂在接口</span>app<span class="token punctuation">.</span>include_router<span class="token punctuation">(</span>translate_router<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 启动服务</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    uvicorn<span class="token punctuation">.</span>run<span class="token punctuation">(</span>        app<span class="token punctuation">,</span>        host <span class="token operator">=</span> app_config<span class="token punctuation">.</span>host<span class="token punctuation">,</span>        port <span class="token operator">=</span> app_config<span class="token punctuation">.</span>port    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>文中涉及代码已上传 <code>GitHub</code>，项目地址：<a href="https://github.com/great-jin/translation-engine">translation-engine</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Hugging Face&lt;/code&gt; 与 &lt;code&gt;GitHub&lt;/code&gt; 相似，专注于 &lt;code&gt;AI&lt;/code&gt; 模型领域的开源社区，拥有丰富的模型可实现快速集成。社区吸引了众多的优秀的开发者及公司机构，源源不断的产出优秀成果。&lt;/p&gt;
&lt;p&gt;今</summary>
      
    
    
    
    <category term="Python" scheme="https://budai.pages.dev/categories/Python/"/>
    
    
    <category term="Python" scheme="https://budai.pages.dev/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>集合随机取数算法</title>
    <link href="https://budai.pages.dev/java/collection/random/"/>
    <id>https://budai.pages.dev/java/collection/random/</id>
    <published>2025-05-21T16:00:00.000Z</published>
    <updated>2025-05-22T13:18:59.040Z</updated>
    
    <content type="html"><![CDATA[<p>默认 <code>JDK</code> 中提供了丰富的集合容器，每个都足以让人眼花缭乱，各自在适用于不同的场景之下。</p><p>在许多的业务中，常常会涉及到随机取数的需求场景，最为典型的莫过于抽奖，更进一步的如题库选题等等。</p><p>面对此类场景基本思路大概分为两类：使用无序集合或打乱有序集合。</p><h4 id="1-无序集合"><a href="#1-无序集合" class="headerlink" title="1. 无序集合"></a>1. 无序集合</h4><p>让我们从最简单的无序集合开始，在 <code>JDK</code> 中最为基础的无序集合莫过于 <code>Set</code> 与 <code>Map</code>。</p><p>如常用的 <code>HashSet</code> 与 <code>HashMap</code> 容器中，其并不以存入的顺序排列，而是以元素的哈希值为依据。</p><p>以 <code>HashSet</code> 为例，下述示例以倒叙存入容器，但输出的结果并非 <code>[5, 4, 3, 2, 1]</code> 而是 <code>[1, 2, 3, 4, 5]</code>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或许你可能也发现了，这类随机其实是一种伪随机。容器中元素不以存入的顺序排列，但仍然依照某类特地规则，如此处即以哈希值为排列依据。</p><p>因此，即便对于无序集合，实现随机访问通常配合 <code>Random</code> 等随机工具类。</p><p>如下述示例即利用 <code>stream</code> 与 <code>Random</code> 实现随机元素取值：</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> Set<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-洗牌算法"><a href="#2-洗牌算法" class="headerlink" title="2. 洗牌算法"></a>2. 洗牌算法</h4><p>针对有序集合的随机取数，最简单方式即打散顺序后访问，实现访问相同位置得到不同的结果。</p><p>在 <code>JDK</code> 中自带了 <code>java.util.Collections#shuffle</code> 方法，基于 <code>Fisher-Yates</code> 算法实现打乱集合顺序。</p><p>针对 <code>ArrayList</code> 容器为例，其实现于 <code>RandomAccess</code> 支持随机访问，底层数据结构为数组即连续的存储空间。从实现源码可以看出，实现逻辑并不复杂，遍历数组并通过 <code>Random</code> 类随机交换两个位置上的元素值从而实现打印的效果。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shuffle</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> list<span class="token punctuation">,</span> Random rnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> SHUFFLE_THRESHOLD <span class="token operator">||</span> list <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>size<span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> rnd<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> list<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> List l <span class="token operator">=</span> list<span class="token punctuation">;</span>    l<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> l<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> l<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成容器元素的顺序打印之后，实现随机取值的则通过 <code>get()</code> 访问即可，每次洗牌后的集合顺序都并会相同，访问同一位置的元素返回的值也将不一样。</p><p>若要批量随机取数，则可对洗牌后的集合通过 <code>subList()</code> 取子集合实现。</p><h4 id="3-随机取数"><a href="#3-随机取数" class="headerlink" title="3. 随机取数"></a>3. 随机取数</h4><p>在 <code>shuffle()</code> 洗牌方法中，可以看出算法的时间复杂为 <code>O(n)</code>，那是否有更优的方式。</p><p>以实际业务场景为例，系统中存在一个 <code>1w</code> 大小的题库，每次需要从中抽取 <code>20</code> 道不重复题目。若采用 <code>shuffle</code> 方式显然每次都需对原集合打乱，造成一定的性能浪费。</p><p>因此，对于一个大小为 <code>m</code> 的容器，且需随机取 <code>n</code> 个元素，若 <code>m &gt;&gt; n</code> 则显然洗牌算法并不适用。</p><p>对于此类场景，最合适的方案以利用数组支持随机访问的特性，变量容器身上聚焦于抽取的元素上。</p><p>如下述代码示例即基于 <code>Random</code> 实现了有序集合的随机取 <code>5</code> 个数，而时间复杂度则无关容器大小，只与取数数量正相关。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> List<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer ele <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 存在则跳过</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;默认 &lt;code&gt;JDK&lt;/code&gt; 中提供了丰富的集合容器，每个都足以让人眼花缭乱，各自在适用于不同的场景之下。&lt;/p&gt;
&lt;p&gt;在许多的业务中，常常会涉及到随机取数的需求场景，最为典型的莫过于抽奖，更进一步的如题库选题等等。&lt;/p&gt;
&lt;p&gt;面对此类场景基本思路大概分为两</summary>
      
    
    
    
    <category term="JAVA集合" scheme="https://budai.pages.dev/categories/JAVA%E9%9B%86%E5%90%88/"/>
    
    
    <category term="JAVA" scheme="https://budai.pages.dev/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JavaPackager 使用教程</title>
    <link href="https://budai.pages.dev/build/pkg/"/>
    <id>https://budai.pages.dev/build/pkg/</id>
    <published>2025-05-10T16:00:00.000Z</published>
    <updated>2025-05-13T12:40:34.802Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知 <code>Java</code> 基于 <code>JVM</code> 实现了跨平台，即一次编译任意平台运行，只需 <code>JRE</code> 运行环境即可。</p><p>跨平台的特性也是市面一系列产品如 <code>IDEA</code> 以及 <code>DBeaver</code> 等应用选择 <code>Java</code> 作为开发语言的一大原因。</p><p>虽然 <code>Java</code> 提供了跨平台的功能，但默认编译后的程序为 <code>jar</code> 文件，在发布时显然不够优雅。常常我们会通过各类工具将其二次编译为对应系统可直接运行的程序，例如在 <code>Windows</code> 下编译为 <code>exe</code> 程序，<code>Mac</code> 环境下的 <code>dmg</code> 等等。</p><p>但 <code>Java</code> 默认并不提供 <code>exe</code> 打包方式，需要借助其它工具。以 <code>Windows</code> 平台为例，可以选择 <code>exe4j</code> 工具，如果是新项目则可采用 <code>GraalVM</code> 编译为 <code>native image</code> 运行，二者都可生成 <code>exe</code> 可运行程序。</p><p><code>Exe4j</code> 与 <code>GraalVM</code> 虽然都可实现 <code>exe</code> 打包，但各有优缺点。前者默认打包后启动默认自带弹窗提示，后者则对旧项目并不友好。</p><p>而今天所分享的 <code>JavaPackager</code> 则可通过 <code>Maven Plugin</code> 插件的方式无感集成项目，提供 <code>Windows</code>、<code>Linux</code> 与 <code>Mac</code> 多平台程序构建，下面就让我们直接开始把。</p><h4 id="1-项目准备"><a href="#1-项目准备" class="headerlink" title="1. 项目准备"></a>1. 项目准备</h4><p>在开始之前，让我们先准备一个简单的 <code>Swing</code> 程序。</p><p>在之前的 <code>Maven</code> 教程中提过，项目默认在打包 <code>jar</code> 文件时并不会将所带的依赖一并编译，常通过 <code>assembly</code> 等插件实现 <code>fat jar</code> 构建。</p><p>而在 <code>JavaPackager</code> 中已经提供了此功能，因此无需额外引入其它插件，这里引入 <code>Jackson</code> 为例演示打包后的效果。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.19.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成后让我们实现一个简单的 <code>Swing</code> 窗口程序。</p><p>程序内容并不复杂，通过 <code>Jackson</code> 序列化 <code>Map</code> 实例并展示的串口中，完整代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PkgClient</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> JsonProcessingException <span class="token punctuation">{</span>        JFrame frame <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JFrame</span><span class="token punctuation">(</span><span class="token string">"PKG Client"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        frame<span class="token punctuation">.</span><span class="token function">setSize</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        frame<span class="token punctuation">.</span><span class="token function">setDefaultCloseOperation</span><span class="token punctuation">(</span>JFrame<span class="token punctuation">.</span>EXIT_ON_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span>        frame<span class="token punctuation">.</span><span class="token function">setLocationRelativeTo</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        frame<span class="token punctuation">.</span><span class="token function">setResizable</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 添加内容</span>        frame<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">createTextPanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        frame<span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> JPanel <span class="token function">createTextPanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> JsonProcessingException <span class="token punctuation">{</span>        JPanel panel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JPanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        panel<span class="token punctuation">.</span><span class="token function">setLayout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BoxLayout</span><span class="token punctuation">(</span>panel<span class="token punctuation">,</span> BoxLayout<span class="token punctuation">.</span>Y_AXIS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> Map<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>                <span class="token string">"id"</span><span class="token punctuation">,</span> <span class="token string">"123"</span><span class="token punctuation">,</span>                <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Alex"</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 添加文本</span>        JLabel label <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JLabel</span><span class="token punctuation">(</span>mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">,</span> SwingConstants<span class="token punctuation">.</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span>        label<span class="token punctuation">.</span><span class="token function">setAlignmentX</span><span class="token punctuation">(</span>Component<span class="token punctuation">.</span>CENTER_ALIGNMENT<span class="token punctuation">)</span><span class="token punctuation">;</span>        panel<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> panel<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行程序，可以得到下图中效果：<br><img src="/album/loading.gif" data-original="/album/article/java/pkg/1.png"></p><h4 id="2-基础编译"><a href="#2-基础编译" class="headerlink" title="2. 基础编译"></a>2. 基础编译</h4><p>那么现在我们就可以执行编译工作，先以最简化的配置开始，编译 <code>Windows</code> 下的 <code>exe</code> 程序。</p><p>在项目的 <code>pom</code> 文件中添加 <code>javapackager</code> 插件，其中 <code>phase = package</code> 即表示作用于 <code>mvn package</code> 打包期间。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.github.fvarrui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javapackager<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.7.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>PkgClient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">></span></span>xyz.ibudai.pkg.PkgClient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>platform</span><span class="token punctuation">></span></span>windows<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>platform</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bundleJre</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bundleJre</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jrePath</span><span class="token punctuation">></span></span>C:\Program Files\Java\jdk-17.0.7\jre<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jrePath</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>createZipball</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>createZipball</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述配置中核心的配置项说明参考下表：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">方法</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">name</td>        <td style="text-align: center;">编译后的目录以及应用名，默认为类名以 - 分隔。</td>    </tr>    <tr>        <td style="text-align: center;">mainClass</td>        <td style="text-align: center;">主类的完整限定名。</td>    </tr>    <tr>        <td style="text-align: center;">platform</td>        <td style="text-align: center;">目标平台，可选值：auto|linux|mac|windows</td>    </tr>    <tr>        <td style="text-align: center;">bundleJre</td>        <td style="text-align: center;">是否生成 JRE，若否编译后文件允许需系统带 JRE。</td>    </tr>    <tr>        <td style="text-align: center;">jrePath</td>        <td style="text-align: center;">若 bundleJre 为 true，可指定 jre 目录。</td>    </tr>    <tr>        <td style="text-align: center;">createZipball</td>        <td style="text-align: center;">是否生成 -platform 后缀的 zip 文件，解压即可运行。</td>    </tr></table></br><p>添加配置后执行 <code>mvn package</code> 命令后即会在 <code>target</code> 目录生成下述内容。<br><img src="/album/loading.gif" data-original="/album/article/java/pkg/2.png"></p><p>图中 <code>-windows.zip</code> 文件解压缩后内容与 <code>PkgClient</code> 目录内容一致，包含下述文件：<br><img src="/album/loading.gif" data-original="/album/article/java/pkg/3.png"></p><p>其中 <code>exe</code> 即可执行程序，<code>libs</code> 即项目所依赖的 <code>jar</code> 包，在上述的工程中即 <code>Jackson</code> 相应 <code>jar</code> 文件。</p><p>而 <code>jre</code> 目录即 <code>Java</code> 运行环境，通过 <code>bundleJre</code> 参数控制是否生成，若否则生成的打包文件中不会包含这部分内容，也就意味在运行时需要对应的系统配置 <code>Java</code> 环境。默认其为拷贝当前系统 <code>Java</code> 所配置的版本，当然你也可以通过 <code>jrePath</code> 指定版本。</p><h4 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3. 环境变量"></a>3. 环境变量</h4><p>运行 <code>Java</code> 程序时，在部分场景下常常我们会通过 <code>-D</code> 等等方式添加变量，亦或调整 <code>JVM</code> 参数。</p><p>在让 <code>JavaPackager</code> 编译后的文件运行时添加启动参数十分简单，在生成的 <code>exe</code> 下添加同级文件 <code>xxx.l4j.ini</code> 文件即可，其中 <code>xxx</code> 为上述 <code>name</code> 标签配置的值。</p><p>例如上述示例中，则新加 <code>PkgClient.l4j.ini</code> 文件后放于 <code>exe</code> 同级即可，文件中的内容按照一行一条的格式。</p><pre class="line-numbers language-ini"><code class="language-ini">-Xms16m<span class="token constant">-Dswing.aatext</span><span class="token attr-value"><span class="token punctuation">=</span>true</span><span class="token constant">-Dsomevar</span><span class="token attr-value"><span class="token punctuation">=</span>"%SOMEVAR%"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如需要添加参数 <code>info.message=hello</code>，则在文件中添加下述内容：</p><pre class="line-numbers language-ini"><code class="language-ini"><span class="token constant">-Dinfo.message</span><span class="token attr-value"><span class="token punctuation">=</span>hello</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>稍微调整之前的程序，在窗口中读取配置并展示，代码片段如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> JPanel <span class="token function">createTextPanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    JPanel panel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JPanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    panel<span class="token punctuation">.</span><span class="token function">setLayout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BoxLayout</span><span class="token punctuation">(</span>panel<span class="token punctuation">,</span> BoxLayout<span class="token punctuation">.</span>Y_AXIS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String message <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"info.message"</span><span class="token punctuation">,</span> <span class="token string">"default message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加文本</span>    JLabel label <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JLabel</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> SwingConstants<span class="token punctuation">.</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span>    label<span class="token punctuation">.</span><span class="token function">setAlignmentX</span><span class="token punctuation">(</span>Component<span class="token punctuation">.</span>CENTER_ALIGNMENT<span class="token punctuation">)</span><span class="token punctuation">;</span>    panel<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> panel<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改后重新执行 <code>package</code> 编译项目，创建 <code>PkgClient.l4j.ini</code> 文件置于 <code>exe</code> 同级下并运行程序，可以得到下述效果：<br><img src="/album/loading.gif" data-original="/album/article/java/pkg/4.png"></p><h4 id="4-文件拷贝"><a href="#4-文件拷贝" class="headerlink" title="4. 文件拷贝"></a>4. 文件拷贝</h4><p>在部分需求场景下，我们的项目会依赖外部文件，在打包时需要一并进行复制。</p><p>针对此类场景，<code>JavaPackager</code> 同样提供了 <code>additionalResources</code> 标签用于文件或目录复制。</p><p>假如我们需要将 <code>assets</code> 目录一并复制进打包生成的目录结构中，则修改 <code>pom</code> 配置为下述内容：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>PkgClient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    ...    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>additionalResources</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>additionalResource</span><span class="token punctuation">></span></span>D:\Temporary\assets<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>additionalResource</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>additionalResources</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成后重新执行 <code>packge</code> 命令构建，在生成的结构下可以看到 <code>assets</code> 目录生成成功。<br><img src="/album/loading.gif" data-original="/album/article/java/pkg/5.png"></p><p>这里需要注意一点，<code>.l4j.ini</code> 配置文件默认是通过 <code>additionalResources</code> 实现，若自定义了 <code>additionalResources</code> 属性且仍需要运行参数，则需要显式在 <code>additionalResource</code> 配置 <code>.l4j.ini</code> 文件路径。</p><hr><p><strong>参考链接</strong></p><ul><li><a href="https://github.com/javapackager/JavaPackager">JavaPackager</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;众所周知 &lt;code&gt;Java&lt;/code&gt; 基于 &lt;code&gt;JVM&lt;/code&gt; 实现了跨平台，即一次编译任意平台运行，只需 &lt;code&gt;JRE&lt;/code&gt; 运行环境即可。&lt;/p&gt;
&lt;p&gt;跨平台的特性也是市面一系列产品如 &lt;code&gt;IDEA&lt;/code&gt; 以及 &lt;c</summary>
      
    
    
    
    <category term="编译构建" scheme="https://budai.pages.dev/categories/%E7%BC%96%E8%AF%91%E6%9E%84%E5%BB%BA/"/>
    
    
    <category term="Windows" scheme="https://budai.pages.dev/tags/Windows/"/>
    
    <category term="JAVA" scheme="https://budai.pages.dev/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 集成教程</title>
    <link href="https://budai.pages.dev/db/mongo/integration/"/>
    <id>https://budai.pages.dev/db/mongo/integration/</id>
    <published>2025-05-09T16:00:00.000Z</published>
    <updated>2026-01-06T14:01:16.659Z</updated>
    
    <content type="html"><![CDATA[<p><code>MongoDB</code> 作为典型的 <code>NoSQL</code> 数据库拥有优秀的横向扩展能力，不拘束于关系型数据库中的表结构，无需调整便可实现结构变更。</p><p>今天就让我们了解下如何在普通 <code>Maven</code> 以及 <code>Spring Boot</code> 工程中集成使用 <code>MongoDB</code>。</p><h3 id="一、Maven集成"><a href="#一、Maven集成" class="headerlink" title="一、Maven集成"></a>一、Maven集成</h3><h4 id="1-服务配置"><a href="#1-服务配置" class="headerlink" title="1. 服务配置"></a>1. 服务配置</h4><p>在查找依赖时你可能会发现 <code>Mongo</code> 存在两个配置版本 <code>mongo-java-driver</code> 与 <code>mongodb-driver-sync</code>，前者为旧版依赖其包含异步 <code>API</code> 相对复杂，从 <code>MongoDB 4.0+</code> 开始官方建议使用 <code>mongodb-driver-sync</code>。</p><p>简而言之，如果无兼容历史版本的需要，则优先使用 <code>mongodb-driver-sync</code>，依赖配置如下：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mongodb<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mongodb-driver-sync<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.10.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行数据访问前，最基础的当然还是创建客户端连接对象，代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    String host <span class="token operator">=</span> <span class="token string">"localhost"</span><span class="token punctuation">;</span>    Integer port <span class="token operator">=</span> <span class="token number">27017</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>ServerAddress<span class="token operator">></span> serverList <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServerAddress</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String database <span class="token operator">=</span> <span class="token string">"admin"</span><span class="token punctuation">;</span>    String username <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> password <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MongoClientSettings settings <span class="token operator">=</span> MongoClientSettings<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 超时配置</span>            <span class="token punctuation">.</span><span class="token function">applyToSocketSettings</span><span class="token punctuation">(</span>builder <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                builder<span class="token punctuation">.</span><span class="token function">connectTimeout</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                builder<span class="token punctuation">.</span><span class="token function">readTimeout</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">applyToClusterSettings</span><span class="token punctuation">(</span>builder <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                builder<span class="token punctuation">.</span><span class="token function">serverSelectionTimeout</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 服务信息</span>                builder<span class="token punctuation">.</span><span class="token function">hosts</span><span class="token punctuation">(</span>serverList<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 账号信息</span>            <span class="token punctuation">.</span><span class="token function">credential</span><span class="token punctuation">(</span>MongoCredential<span class="token punctuation">.</span><span class="token function">createScramSha256Credential</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> database<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建客户端</span>    MongoClient client <span class="token operator">=</span> MongoClients<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>settings<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-URI连接"><a href="#2-URI连接" class="headerlink" title="2. URI连接"></a>2. URI连接</h4><p><code>MongoDB</code> 支持多种连接格式，除了上述的连接方式外 <code>MongoDB</code> 同时支持以 <code>URI</code> 方式，其连接格式如下：</p><pre class="line-numbers language-sql"><code class="language-sql">mongodb:<span class="token comment" spellcheck="true">//&lt;username>:&lt;passsword>@&lt;host>:&lt;port>/&lt;collection></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需注意一点，当用户名或密码中包含特殊字符时，在配置 <code>uri</code> 时需要替换为对应的转义字符，否则将无法连接。</p><p>常用的特殊字符及其转义字符参照下表：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">字符</td>        <th style="text-align: center;">编码</td>    </tr>    <tr>        <td style="text-align: center;">@</td>        <td style="text-align: center;">%40</td>    </tr>    <tr>        <td style="text-align: center;">:</td>        <td style="text-align: center;">%3A</td>    </tr>    <tr>        <td style="text-align: center;">/</td>        <td style="text-align: center;">%2F</td>    </tr>    <tr>        <td style="text-align: center;">?</td>        <td style="text-align: center;">%3F</td>    </tr>    <tr>        <td style="text-align: center;">#</td>        <td style="text-align: center;">%23</td>    </tr>    <tr>        <td style="text-align: center;">&</td>        <td style="text-align: center;">%26</td>    </tr>    <tr>        <td style="text-align: center;">=</td>        <td style="text-align: center;">%3D</td>    </tr></table></br><p>其客户端创建类似，将上述的 <code>credential()</code> 替换为 <code>applyConnectionString()</code> 即可，实现代码如下：</p><pre class="line-numbers language-java"><code class="language-java">String url <span class="token operator">=</span> <span class="token string">"mongodb://root:123456@192.168.0.21:27017/test_col?authSource=admin"</span><span class="token punctuation">;</span>MongoClientSettings settings <span class="token operator">=</span> MongoClientSettings<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 超时配置</span>        <span class="token punctuation">.</span><span class="token function">applyToSocketSettings</span><span class="token punctuation">(</span>builder <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            builder<span class="token punctuation">.</span><span class="token function">connectTimeout</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            builder<span class="token punctuation">.</span><span class="token function">readTimeout</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">applyToClusterSettings</span><span class="token punctuation">(</span>builder <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            builder<span class="token punctuation">.</span><span class="token function">serverSelectionTimeout</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 服务信息</span>        <span class="token punctuation">.</span><span class="token function">applyConnectionString</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConnectionString</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-数据新增"><a href="#3-数据新增" class="headerlink" title="3. 数据新增"></a>3. 数据新增</h4><p>想要实现新增数据则十分简单，在获取 <code>MongoCollection</code> 实例后通过相应的 <code>insertOne()</code> 或 <code>insertMany()</code> 方法即可。</p><p>完整调用实现代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MongoRepository</span> <span class="token keyword">implements</span> <span class="token class-name">AutoCloseable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> String database<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> MongoClient mongoClient<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MongoRepository</span><span class="token punctuation">(</span>String database<span class="token punctuation">,</span> MongoClient mongoClient<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>database <span class="token operator">=</span> database<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mongoClient <span class="token operator">=</span> mongoClient<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mongoClient <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mongoClient<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> MongoDatabase <span class="token function">getDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mongoClient<span class="token punctuation">.</span><span class="token function">getDatabase</span><span class="token punctuation">(</span>database<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>String collection<span class="token punctuation">,</span> T t<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MongoCollection<span class="token operator">&lt;</span>T<span class="token operator">></span> mongoCollection <span class="token operator">=</span> <span class="token function">getDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCollection</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> tClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        mongoCollection<span class="token punctuation">.</span><span class="token function">insertOne</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">insertAll</span><span class="token punctuation">(</span>String collection<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> list<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MongoCollection<span class="token operator">&lt;</span>T<span class="token operator">></span> mongoCollection <span class="token operator">=</span> <span class="token function">getDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCollection</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> tClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        mongoCollection<span class="token punctuation">.</span><span class="token function">insertMany</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-数据查询"><a href="#4-数据查询" class="headerlink" title="4. 数据查询"></a>4. 数据查询</h4><p><code>MongoDB</code> 查询数据与新增方式类似，这里直接通过代码演示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">count</span><span class="token punctuation">(</span>String collection<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span> condition<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MongoCollection<span class="token operator">&lt;</span>T<span class="token operator">></span> mongoCollection <span class="token operator">=</span> <span class="token function">getDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">getCollection</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> tClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    mongoCollection<span class="token punctuation">.</span><span class="token function">countDocuments</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Document</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">findOne</span><span class="token punctuation">(</span>String collection<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span> condition<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MongoCollection<span class="token operator">&lt;</span>T<span class="token operator">></span> mongoCollection <span class="token operator">=</span> <span class="token function">getDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">getCollection</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> tClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> mongoCollection<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Document</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">find</span><span class="token punctuation">(</span>String collection<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span> condition<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MongoCollection<span class="token operator">&lt;</span>T<span class="token operator">></span> mongoCollection <span class="token operator">=</span> <span class="token function">getDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">getCollection</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> tClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    FindIterable<span class="token operator">&lt;</span>T<span class="token operator">></span> iterable <span class="token operator">=</span> mongoCollection<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Document</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>T<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>T t <span class="token operator">:</span> iterable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-数据删除"><a href="#5-数据删除" class="headerlink" title="5. 数据删除"></a>5. 数据删除</h4><p>同理，文档记录删除方式如下不再展开介绍。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">boolean</span> <span class="token function">delete</span><span class="token punctuation">(</span>String collection<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span> condition<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MongoCollection<span class="token operator">&lt;</span>T<span class="token operator">></span> mongoCollection <span class="token operator">=</span> <span class="token function">getDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">getCollection</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> tClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> mongoCollection<span class="token punctuation">.</span><span class="token function">deleteMany</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Document</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeletedCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">boolean</span> <span class="token function">deleteOne</span><span class="token punctuation">(</span>String collection<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span> condition<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MongoCollection<span class="token operator">&lt;</span>T<span class="token operator">></span> mongoCollection <span class="token operator">=</span> <span class="token function">getDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">getCollection</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> tClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> mongoCollection<span class="token punctuation">.</span><span class="token function">deleteOne</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Document</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeletedCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、Spring集成"><a href="#二、Spring集成" class="headerlink" title="二、Spring集成"></a>二、Spring集成</h3><h4 id="1-连接配置"><a href="#1-连接配置" class="headerlink" title="1. 连接配置"></a>1. 连接配置</h4><p>在 <code>Spring Boot</code> 中依赖就十分简单了，引入对应的 <code>starter</code> 即可，依赖如下：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-mongodb<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>引入依赖后需在项目中配置 <code>MongoDB</code> 的连接信息，在 <code>application.yml</code> 中添加下述内容。</p><p>这里采用 <code>URI</code> 方式连接，与之前 <code>Maven</code> 方式集成中提到的类似，如果用户名或密码包含特殊字符转替换为转义字符。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">data</span><span class="token punctuation">:</span>    <span class="token key atrule">mongodb</span><span class="token punctuation">:</span>      <span class="token key atrule">uri</span><span class="token punctuation">:</span> mongodb<span class="token punctuation">:</span>//root<span class="token punctuation">:</span>123456@localhost<span class="token punctuation">:</span>27017/test_collection<span class="token punctuation">?</span>authSource=admin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-数据新增"><a href="#2-数据新增" class="headerlink" title="2. 数据新增"></a>2. 数据新增</h4><p>完成配置后即可开始相应访问交互，与 <code>Maven</code> 中不同的是你可以通过 <code>MongoTemplate</code> 便可轻易的实现与 <code>MongoDB</code> 的相应交互。</p><p>在 <code>MongoDB</code> 中提供了两种新增接口 <code>save()</code> 与 <code>insert()</code>，二者最大的区别前者新增时若数据已存在则会报错失败，而 <code>insert()</code> 方法则会直接覆盖旧数据。</p><p>相应的新增方法实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MongoRepository</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> MongoTemplate mongoTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mongoTemplate<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mongoTemplate<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">insertAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span>T<span class="token operator">></span> collection<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mongoTemplate<span class="token punctuation">.</span><span class="token function">insertAll</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-数据查询"><a href="#3-数据查询" class="headerlink" title="3. 数据查询"></a>3. 数据查询</h4><p>在 <code>MongoDB</code> 中通过 <code>Criteria</code> 与 <code>Query</code> 构建查询条件，常用的查询接口参考下表：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">方法</td>        <th style="text-align: center;">描述</td>    </tr>    <tr>        <td style="text-align: center;">count()</td>        <td style="text-align: center;">查询匹配的记录条数。</td>    </tr>    <tr>        <td style="text-align: center;">find()</td>        <td style="text-align: center;">返回所有匹配的记录结果。</td>    </tr>    <tr>        <td style="text-align: center;">findOne()</td>        <td style="text-align: center;">返回匹配记录结果中的一条。</td>    </tr>    <tr>        <td style="text-align: center;">findById()</td>        <td style="text-align: center;">根据文档 ID 精准匹配查询。</td>    </tr></table></br><p>表中所列接口其相应的实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MongoRepository</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> MongoTemplate mongoTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">long</span> <span class="token function">count</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tClass<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mongoTemplate<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token function">createQuery</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">,</span> tClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">find</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tClass<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mongoTemplate<span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span><span class="token function">createQuery</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">,</span> tClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">findById</span><span class="token punctuation">(</span>Object id<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mongoTemplate<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> tClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tClass<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mongoTemplate<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token function">createQuery</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">,</span> tClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> Query <span class="token function">createQuery</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> conditions<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Criteria criteria <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Criteria</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> entry <span class="token operator">:</span> conditions<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            criteria<span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Query</span><span class="token punctuation">(</span>criteria<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;MongoDB&lt;/code&gt; 作为典型的 &lt;code&gt;NoSQL&lt;/code&gt; 数据库拥有优秀的横向扩展能力，不拘束于关系型数据库中的表结构，无需调整便可实现结构变更。&lt;/p&gt;
&lt;p&gt;今天就让我们了解下如何在普通 &lt;code&gt;Maven&lt;/code&gt; 以及 &lt;c</summary>
      
    
    
    
    <category term="中间件" scheme="https://budai.pages.dev/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="MongoDB" scheme="https://budai.pages.dev/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Maven系统依赖打包</title>
    <link href="https://budai.pages.dev/build/maven/system/"/>
    <id>https://budai.pages.dev/build/maven/system/</id>
    <published>2025-01-17T16:00:00.000Z</published>
    <updated>2025-05-11T12:39:12.812Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的博客中详细介绍了通过 <code>Maven</code> 实现项目的依赖管理，以及实现工程的编译构建。</p><p>熟话说巧妇难为无米之炊，实现依赖管理的前提都是需要中央仓库或本地仓库存在对应的依赖，如果依赖不存在也只能望洋兴叹。</p><p>但这类场景在开发中却又并不少见，对于某个功能涉及的依赖包经过一顿网上冲浪，终于找到了依赖文件，但依赖并未上传中央仓库无法直接集成依赖。</p><h4 id="1-系统依赖"><a href="#1-系统依赖" class="headerlink" title="1. 系统依赖"></a>1. 系统依赖</h4><p>幸运的是 <code>Maven</code> 的依赖导入提供了本地文件的引用导入，在定义依赖时将 <code>scope</code> 作用域定义为 <code>system</code> 同时通过 <code>systemPath</code> 用于指定依赖文件的路径。</p><p>例如下述示例即读取 <code>D:/repo/demo-one-1.0-SNAPSHOT.jar</code> 目录文件作为依赖包，而非从默认配置的 Maven 仓库中检索查找。如此一来，即便某个依赖文件不存在于仓库之中，仍能正常引入工程。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>xyz.ibudai<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo-one<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>system<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>systemPath</span><span class="token punctuation">></span></span>D:/repo/demo-one-1.0-SNAPSHOT.jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>systemPath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-仓库结构"><a href="#2-仓库结构" class="headerlink" title="2. 仓库结构"></a>2. 仓库结构</h4><p>在继续下一步的介绍之前，让我们先来看一下 <code>Maven</code> 仓库对于依赖文件是以何种结构进行管理？</p><p>在定义一个 <code>Maven</code> 工程时，我们都知道 <code>groupId</code>，<code>artifactId</code> 与 <code>version</code> 三者是必不可少，分别声明了依赖的所属、名称以及版本信息，例如下述示例所展示：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>xyz.ibudai<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo-one<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那你是否又好奇这个模块又是如何存储在 <code>Maven</code> 仓库之中？</p><p>实际上存储结构也简单明了，打开 <code>Maven</code> 配置的仓库目录中，可以看到依赖的存储路径是以 <code>groupId</code>，<code>artifactId</code> 与 <code>version</code> 三者作为目录路径存储，同时针对 <code>groupId</code> 中的 <code>.</code> 按次序拆分为多个目录。</p><p>例如上述定义的模块通过 <code>install</code> 命令后将生成的文件目录结构如下，而文件名默认以 <code>&lt;artifactId&gt;-&lt;version&gt;.jar</code> 的命名规则存在。<br><img src="/album/loading.gif" data-original="/album/article/java/maven/structure.png"></p><h4 id="3-工程编译"><a href="#3-工程编译" class="headerlink" title="3. 工程编译"></a>3. 工程编译</h4><p>了解了上述概念后，让我们来看一下 <code>Maven</code> 又是如何对工程进行编译打包。</p><p>默认 <code>Maven</code> 在打包构建时并不会将模块所依赖的模块一同打包进 jar 可执行文件，而是只会打包当前工程 <code>src/main</code>  包路径的代码文件。因此，若需要将工程的依赖一并打包通常需要利用到 <code>Assembly</code> 等构建插件，在之前的博客中分享过了如何使用这里就不再重复展开。</p><p>这里就直接贴出完整的 <code>Assembly</code> 插件打包配置，内容如下：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-assembly-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>finalName</span><span class="token punctuation">></span></span>${project.artifactId}-${project.version}-all<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>finalName</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appendAssemblyId</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appendAssemblyId</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptorRefs</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptorRef</span><span class="token punctuation">></span></span>jar-with-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptorRef</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptorRefs</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>attach</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>attach</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>archive</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifest</span><span class="token punctuation">></span></span>                  <span class="token comment" spellcheck="true">&lt;!-- 替换为主类完整限定名 --></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">></span></span>fully.qualified.MainClass<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">></span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>addDefaultSpecificationEntries</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>addDefaultSpecificationEntries</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>addDefaultImplementationEntries</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>addDefaultImplementationEntries</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifest</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>archive</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>make-assembly<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>single<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在工程 <code>pom.xml</code> 文件中添加上述配置之后执行 <code>packge</code> 命令即可在 <code>target</code> 目录下生成 <code>xxx-all.jar</code> 可执行文件，文件内包含了工程的源码以及所有依赖的模块。</p><p>但如果你仔细观察的话，文件的确是将依赖的模块一并打包，但是刚才提到的 <code>scope=system</code> 依赖却并没有出现在打包后的文件中。</p><p>是的，你并没有看错，<code>Assembly</code> 插件将会跳过 <code>scope=system</code> 依赖模块，那又该如何处理？</p><p>这里就要回到刚才介绍的依赖文件存储结构了，不仅文件的生成是基于 <code>groupId</code>，<code>artifactId</code> 与 <code>version</code> 三者，在定义 <code>dependency</code> 时 <code>Maven</code> 同样也是由此为依据在仓库中检索文件。但解决方案就有了，只要根据此规则为 <code>scope=system</code> 依赖创建同样的目录，那即可直接引用依赖无需将作用域定义于 <code>system</code>。</p><p>最简单的方式就是手动创建目录，但 <code>Maven</code> 对此提供了更方便的方式，命令模板如下：</p><pre class="line-numbers language-bash"><code class="language-bash">mvn install:install-file \  -Dfile<span class="token operator">=</span><span class="token operator">&lt;</span>path-to-file<span class="token operator">></span> \  -DgroupId<span class="token operator">=</span><span class="token operator">&lt;</span>my-groupId<span class="token operator">></span> \  -DartifactId<span class="token operator">=</span><span class="token operator">&lt;</span>my-artifactId<span class="token operator">></span> \  -Dversion<span class="token operator">=</span><span class="token operator">&lt;</span>my-version<span class="token operator">></span> \  -Dpackaging<span class="token operator">=</span><span class="token operator">&lt;</span>my-packaging<span class="token operator">></span> \  -DlocalRepositoryPath<span class="token operator">=</span><span class="token operator">&lt;</span>path-to-repo<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如之前提到 <code>demo-one-1.0-SNAPSHOT.jar</code> 文件，通过下述命令即可在 <code>Maven</code> 仓库中生成对应的结构的目录。</p><pre class="line-numbers language-bash"><code class="language-bash">mvn install:install-file \  -Dfile<span class="token operator">=</span> \  -DgroupId<span class="token operator">=</span>xyz.ibudai \  -DartifactId<span class="token operator">=</span>demo-one \  -Dversion<span class="token operator">=</span>1.0-SNAPSHOT \  -Dpackaging<span class="token operator">=</span>jar \  -DlocalRepositoryPath<span class="token operator">=</span>D:/repo/demo-one-1.0-SNAPSHOT.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那问题也迎刃而解，此时在项目中依赖 <code>demo-one</code> 模块则需要通过 <code>system</code> 执行，和其它依赖一样引用即可。与此同时，再通过 <code>Assembly</code> 插件也可正常实现打包构建。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>xyz.ibudai<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>demo-one<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的方式适用于本地的项目编译构建，依赖文件在本地仓库中是生成了，但线上私服仓库中仍然不存在此依赖文件。</p><p>因此，若需要实现在线编译，同样需要通过 <code>deploy</code> 命令将依赖推送到私服，命令格式如下：</p><pre class="line-numbers language-bash"><code class="language-bash">mvn deploy:deploy-file \  -Dfile<span class="token operator">=</span><span class="token operator">&lt;</span>path-to-file<span class="token operator">></span> \  -DgroupId<span class="token operator">=</span><span class="token operator">&lt;</span>my-groupId<span class="token operator">></span> \  -DartifactId<span class="token operator">=</span><span class="token operator">&lt;</span>my-artifactId<span class="token operator">></span> \  -Dversion<span class="token operator">=</span><span class="token operator">&lt;</span>my-version<span class="token operator">></span> \  -Dpackaging<span class="token operator">=</span><span class="token operator">&lt;</span>my-packaging<span class="token operator">></span> \  -DrepositoryId<span class="token operator">=</span><span class="token operator">&lt;</span>repository-id<span class="token operator">></span> \  -Durl<span class="token operator">=</span><span class="token operator">&lt;</span>repository-url<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在之前的博客中详细介绍了通过 &lt;code&gt;Maven&lt;/code&gt; 实现项目的依赖管理，以及实现工程的编译构建。&lt;/p&gt;
&lt;p&gt;熟话说巧妇难为无米之炊，实现依赖管理的前提都是需要中央仓库或本地仓库存在对应的依赖，如果依赖不存在也只能望洋兴叹。&lt;/p&gt;
&lt;p&gt;但这类场景在开发</summary>
      
    
    
    
    <category term="编译构建" scheme="https://budai.pages.dev/categories/%E7%BC%96%E8%AF%91%E6%9E%84%E5%BB%BA/"/>
    
    
    <category term="Maven" scheme="https://budai.pages.dev/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Java 模块化特性</title>
    <link href="https://budai.pages.dev/java/jdk/module/"/>
    <id>https://budai.pages.dev/java/jdk/module/</id>
    <published>2025-01-11T16:00:00.000Z</published>
    <updated>2025-05-11T12:39:12.936Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Java</code> 的不断更新迭代中 <code>JDK</code> 加入了一系列新的特性，而在 <code>JDK 9</code> 中则引入了全新的模块化特性，为工程结构管理提供了基础保障。</p><p>我们都知道在 <code>Maven</code> 中可以通过 <code>module</code> 实现模块的管理，<code>JDK</code> 的模块化则有异曲同工之妙。</p><p>下面就让我们来看一下模块块的作用以及引入其的目的。</p><h4 id="1-基础介绍"><a href="#1-基础介绍" class="headerlink" title="1. 基础介绍"></a>1. 基础介绍</h4><p>首先让我们看一下在 <code>JDK 8</code> 以及之前 <code>Java</code> 类的存储方式，在 <code>Java</code> 的安装目录下，可以看到所有的 <code>Java</code> 类都被放在 <code>src.zip</code> 文件。<br><img src="/album/loading.gif" data-original="/album/article/java/module/1.png"></p><p>再看一下 <code>JDK 9</code> 之后的安装目录，这里以 <code>JDK 11</code> 为例，你会发现此时  <code>src.zip</code> 文件已然不存在，取而代之是新增了 <code>jmods</code> 目录，目录下存放着一系列 <code>.jmod</code> 文件。<br><img src="/album/loading.gif" data-original="/album/article/java/module/2.png"></p><p>那这些 <code>jmod</code> 文件又是什么？这个正是本文的重点，也是模块化的核心。</p><p>在 <code>JDK 8</code> 之前所有模块都是打包为一个文件，即便是只用到单个类，仍需要全局依赖。同时，在之前的版本中对于作用域的限制过于宽泛，虽然 <code>private</code> 等可以实现访问限制，但反射的存在让这个限制形同虚设。</p><p>因此，在 <code>JDK 9</code> 中引入了模块化概念，将 <code>src.zip</code> 拆分为独立的 <code>jmod</code> 文件，每个子模块之间相互独立，使得工程管理更为轻量化。</p><h4 id="2-模块创建"><a href="#2-模块创建" class="headerlink" title="2. 模块创建"></a>2. 模块创建</h4><p>了解了模块化的基本信息，让我们来看一下如何创建一个模块化工程？</p><p>实现方式也十分简单，通过 <code>module-info.java</code> 文件进程模块内类的管理，如果你打开上述提到的 <code>jmod</code> 文件，即可发现文件内正包含此文件。<br><img src="/album/loading.gif" data-original="/album/article/java/module/3.png"></p><p>接下来让我们来看一下 <code>module-info.java</code> 文件的内容结构，其定义模板如下：</p><table style="display: table; margin-left: auto; margin-right: auto;">    <tr>        <th style="text-align: center;">方法</td>        <th style="text-align: center;">作用</td>    </tr>    <tr>        <td style="text-align: center;">module</td>        <td style="text-align: center;">指定当前模块的模块名。</td>    </tr>    <tr>        <td style="text-align: center;">requires</td>        <td style="text-align: center;">定义此模块所依赖的模块。</td>    </tr>    <tr>        <td style="text-align: center;">exports</td>        <td style="text-align: center;">定义此模块对外可以访问的包路径。</td>    </tr></table></br><pre class="line-numbers language-java"><code class="language-java">module <span class="token operator">&lt;</span>module<span class="token punctuation">.</span>name<span class="token operator">></span> <span class="token punctuation">{</span>    requires <span class="token operator">&lt;</span>other<span class="token punctuation">.</span>module<span class="token punctuation">.</span>name<span class="token operator">></span><span class="token punctuation">;</span>    exports <span class="token operator">&lt;</span><span class="token keyword">package</span><span class="token punctuation">.</span>name<span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果一个类所在的包路径没有通过 <code>exports</code> 对外暴露，则其它模块无法使用此类，对于类的访问进一步作出限制，即便通过反射方式调用仍无法访问。</p><p>在 <code>exports</code> 中同时提供了 <code>to</code> 关键字用于配置将包只暴露给指定的模块，实现更精细化的控制，如下述示例中即只将包 <code>xyz.ibudai.test</code> 开放给 <code>my.mod</code> 模块。</p><pre class="line-numbers language-java"><code class="language-java">module test<span class="token punctuation">.</span>mod <span class="token punctuation">{</span>    exports xyz<span class="token punctuation">.</span>ibudai<span class="token punctuation">.</span>test to my<span class="token punctuation">.</span>mod<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同时每个模块默认都隐式依赖 <code>java.base</code> 模块，因此 <code>requires java.base;</code> 无需手动声明。</p><p>而 <code>java.base</code> 模块则正是 <code>Java</code> 的核心基础类模块，查看该模块文件即可看到其通过 <code>exports</code> 对外开放了 <code>java.lang</code> 等一系列核心包。<br><img src="/album/loading.gif" data-original="/album/article/java/module/4.png"></p><h4 id="3-模块编译"><a href="#3-模块编译" class="headerlink" title="3. 模块编译"></a>3. 模块编译</h4><p>那如何将编译自己的 <code>jmod</code> 模块文件呢？其实也十分简单，首先将工程编译为 <code>jar</code> 文件，再由 <code>jmod create</code> 命令即可，格式如下：</p><pre class="line-numbers language-bash"><code class="language-bash">jmod create --class-path <span class="token operator">&lt;</span>target.jar<span class="token operator">></span> <span class="token operator">&lt;</span>target.jmod<span class="token operator">></span><span class="token comment" spellcheck="true"># Example</span>jmod create --class-path hello.jar hello.jmod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-示例分析"><a href="#4-示例分析" class="headerlink" title="4. 示例分析"></a>4. 示例分析</h4><p>下面通过示例演示模块化的效果。</p><p>新建工程 <code>module-1</code>，并创建包目录 <code>xyz.ibudai.practice.jdk.pack1</code> 并定义类 <code>Demo1</code>，代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> xyz<span class="token punctuation">.</span>ibudai<span class="token punctuation">.</span>pack1<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Demo 1 say hello."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理，新建包目录 <code>xyz.ibudai.practice.jdk.pack2</code> 并定义两个类 <code>Demo2</code>，这里就不再展示代码内容。</p><p>接下来让我们定义对应的 <code>module-info.java</code> 模块文件，注意文件名是固定的。在模块文件中通过 <code>exports</code> 关键字将包 <code>xyz.ibudai.practice.jdk.pack1</code> 对外暴露。</p><pre class="line-numbers language-java"><code class="language-java">module ibudai<span class="token punctuation">.</span>base1 <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 默认依赖 java.base，可省略 */</span>    requires java<span class="token punctuation">.</span>base<span class="token punctuation">;</span>    exports xyz<span class="token punctuation">.</span>ibudai<span class="token punctuation">.</span>practice<span class="token punctuation">.</span>jdk<span class="token punctuation">.</span>pack1<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新建另一工程 <code>module-2</code>，配置其模块文件 <code>module-info.java</code> 内容如下：</p><pre class="line-numbers language-java"><code class="language-java">module ibudai<span class="token punctuation">.</span>base2 <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 依赖 ibudai.base1 */</span>    requires ibudai<span class="token punctuation">.</span>base1<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此新工程中新建测试类执行调用 <code>Demo1</code> 的静态方法能够正常执行，但如果尝试调用 <code>Demo2</code> 编译器则会提升包未对外导出。<br><img src="/album/loading.gif" data-original="/album/article/java/module/5.png"></p><h4 id="5-强制访问"><a href="#5-强制访问" class="headerlink" title="5. 强制访问"></a>5. 强制访问</h4><p>作为一身反骨的 <code>Javaer</code> 而言，如果某个包没有对外暴露，那应该如何解决？</p><p><code>Java</code> 仍给我们留了一条后路，在编译时添加下述命令：</p><pre class="line-numbers language-bash"><code class="language-bash">--add-exports ibudai.base/xyz.ibudai.practice.jdk.pack2<span class="token operator">=</span>ALL-UNNAMED<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/album/loading.gif" data-original="/album/article/java/module/6.png"></p><p>在启动时添加下述命令：</p><pre class="line-numbers language-bash"><code class="language-bash">--add-opens ibudai.base/xyz.ibudai.practice.jdk.pack2<span class="token operator">=</span>ALL-UNNAMED<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/album/loading.gif" data-original="/album/article/java/module/7.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;code&gt;Java&lt;/code&gt; 的不断更新迭代中 &lt;code&gt;JDK&lt;/code&gt; 加入了一系列新的特性，而在 &lt;code&gt;JDK 9&lt;/code&gt; 中则引入了全新的模块化特性，为工程结构管理提供了基础保障。&lt;/p&gt;
&lt;p&gt;我们都知道在 &lt;code&gt;Maven&lt;/c</summary>
      
    
    
    
    <category term="JAVA基础" scheme="https://budai.pages.dev/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JAVA" scheme="https://budai.pages.dev/tags/JAVA/"/>
    
  </entry>
  
</feed>
